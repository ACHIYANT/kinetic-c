.TH "kinetic_session.c" 3 "Tue Mar 3 2015" "Version v0.12.0-beta" "kinetic-c" \" -*- nroff -*-
.ad l
.nh
.SH NAME
kinetic_session.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'kinetic_session\&.h'\fP
.br
\fC#include 'kinetic_types_internal\&.h'\fP
.br
\fC#include 'kinetic_controller\&.h'\fP
.br
\fC#include 'kinetic_socket\&.h'\fP
.br
\fC#include 'kinetic_response\&.h'\fP
.br
\fC#include 'kinetic_operation\&.h'\fP
.br
\fC#include 'kinetic_allocator\&.h'\fP
.br
\fC#include 'kinetic_resourcewaiter\&.h'\fP
.br
\fC#include 'kinetic_logger\&.h'\fP
.br
\fC#include <stdlib\&.h>\fP
.br
\fC#include <string\&.h>\fP
.br
\fC#include <pthread\&.h>\fP
.br
\fC#include <errno\&.h>\fP
.br
\fC#include <sys/time\&.h>\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBATOMIC_FETCH_AND_INCREMENT\fP(P)   __sync_fetch_and_add(P, 1)"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBKineticStatus\fP \fBKineticSession_Create\fP (KineticSession *const session, KineticClient *const client)"
.br
.ti -1c
.RI "\fBKineticStatus\fP \fBKineticSession_Destroy\fP (KineticSession *const session)"
.br
.ti -1c
.RI "\fBKineticStatus\fP \fBKineticSession_Connect\fP (KineticSession *const session)"
.br
.ti -1c
.RI "\fBKineticStatus\fP \fBKineticSession_Disconnect\fP (KineticSession const *const session)"
.br
.ti -1c
.RI "int64_t \fBKineticSession_GetNextSequenceCount\fP (KineticSession const *const session)"
.br
.ti -1c
.RI "int64_t \fBKineticSession_GetClusterVersion\fP (KineticSession const *const session)"
.br
.ti -1c
.RI "void \fBKineticSession_SetClusterVersion\fP (KineticSession *const session, int64_t cluster_version)"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define ATOMIC_FETCH_AND_INCREMENT(P)   __sync_fetch_and_add(P, 1)"

.PP
Definition at line 172 of file kinetic_session\&.c\&.
.SH "Function Documentation"
.PP 
.SS "\fBKineticStatus\fP KineticSession_Create (KineticSession *constsession, KineticClient *constclient)"

.PP
Definition at line 37 of file kinetic_session\&.c\&.
.PP
References KINETIC_ASSERT, KINETIC_MAX_OUTSTANDING_OPERATIONS_PER_SESSION, KINETIC_STATUS_MEMORY_ERROR, KINETIC_STATUS_SESSION_EMPTY, KINETIC_STATUS_SUCCESS, KineticAllocator_FreeConnection(), KineticAllocator_NewConnection(), KineticCountingSemaphore_Create(), and LOG0\&.
.SS "\fBKineticStatus\fP KineticSession_Destroy (KineticSession *constsession)"

.PP
Definition at line 74 of file kinetic_session\&.c\&.
.PP
References KINETIC_STATUS_SESSION_EMPTY, KINETIC_STATUS_SESSION_INVALID, KINETIC_STATUS_SUCCESS, KineticAllocator_FreeConnection(), KineticAllocator_FreeSession(), and KineticCountingSemaphore_Destroy()\&.
.SS "\fBKineticStatus\fP KineticSession_Connect (KineticSession *constsession)"

.PP
Definition at line 91 of file kinetic_session\&.c\&.
.PP
References bus_register_socket(), BUS_SOCKET_PLAIN, BUS_SOCKET_SSL, KINETIC_ASSERT, KINETIC_CONNECTION_TIMEOUT_SECS, KINETIC_SOCKET_DESCRIPTOR_INVALID, KINETIC_STATUS_CONNECTION_ERROR, KINETIC_STATUS_MEMORY_ERROR, KINETIC_STATUS_SESSION_EMPTY, KINETIC_STATUS_SUCCESS, KineticResourceWaiter_WaitTilAvailable(), KineticSocket_Close(), KineticSocket_Connect(), LOG0, LOGF1, and PDU_PROTO_MAX_LEN\&.
.SS "\fBKineticStatus\fP KineticSession_Disconnect (KineticSession const *constsession)"

.PP
Definition at line 151 of file kinetic_session\&.c\&.
.PP
References bus_release_socket(), KINETIC_HANDLE_INVALID, KINETIC_STATUS_CONNECTION_ERROR, KINETIC_STATUS_SESSION_EMPTY, and KINETIC_STATUS_SUCCESS\&.
.SS "int64_t KineticSession_GetNextSequenceCount (KineticSession const *constsession)"

.PP
Definition at line 174 of file kinetic_session\&.c\&.
.PP
References ATOMIC_FETCH_AND_INCREMENT\&.
.SS "int64_t KineticSession_GetClusterVersion (KineticSession const *constsession)"

.PP
Definition at line 181 of file kinetic_session\&.c\&.
.SS "void KineticSession_SetClusterVersion (KineticSession *constsession, int64_tcluster_version)"

.PP
Definition at line 187 of file kinetic_session\&.c\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for kinetic-c from the source code\&.
