.TH "kinetic_session.c" 3 "Fri Mar 13 2015" "Version v0.12.0" "kinetic-c" \" -*- nroff -*-
.ad l
.nh
.SH NAME
kinetic_session.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'kinetic_session\&.h'\fP
.br
\fC#include 'kinetic_types_internal\&.h'\fP
.br
\fC#include 'kinetic_controller\&.h'\fP
.br
\fC#include 'kinetic_socket\&.h'\fP
.br
\fC#include 'kinetic_response\&.h'\fP
.br
\fC#include 'kinetic_operation\&.h'\fP
.br
\fC#include 'kinetic_allocator\&.h'\fP
.br
\fC#include 'kinetic_resourcewaiter\&.h'\fP
.br
\fC#include 'kinetic_logger\&.h'\fP
.br
\fC#include <stdlib\&.h>\fP
.br
\fC#include <string\&.h>\fP
.br
\fC#include <pthread\&.h>\fP
.br
\fC#include <errno\&.h>\fP
.br
\fC#include <sys/time\&.h>\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBATOMIC_FETCH_AND_INCREMENT\fP(P)   __sync_fetch_and_add(P, 1)"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBKineticStatus\fP \fBKineticSession_Create\fP (KineticSession *const session, KineticClient *const client)"
.br
.ti -1c
.RI "\fBKineticStatus\fP \fBKineticSession_Destroy\fP (KineticSession *const session)"
.br
.ti -1c
.RI "\fBKineticStatus\fP \fBKineticSession_Connect\fP (KineticSession *const session)"
.br
.ti -1c
.RI "\fBKineticStatus\fP \fBKineticSession_Disconnect\fP (KineticSession *const session)"
.br
.ti -1c
.RI "\fBKineticStatus\fP \fBKineticSession_GetTerminationStatus\fP (KineticSession const *const session)"
.br
.ti -1c
.RI "void \fBKineticSession_SetTerminationStatus\fP (KineticSession *const session, \fBKineticStatus\fP status)"
.br
.ti -1c
.RI "int64_t \fBKineticSession_GetNextSequenceCount\fP (KineticSession *const session)"
.br
.ti -1c
.RI "int64_t \fBKineticSession_GetClusterVersion\fP (KineticSession const *const session)"
.br
.ti -1c
.RI "void \fBKineticSession_SetClusterVersion\fP (KineticSession *const session, int64_t cluster_version)"
.br
.ti -1c
.RI "int64_t \fBKineticSession_GetConnectionID\fP (KineticSession const *const session)"
.br
.ti -1c
.RI "void \fBKineticSession_SetConnectionID\fP (KineticSession *const session, int64_t id)"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define ATOMIC_FETCH_AND_INCREMENT(P)   __sync_fetch_and_add(P, 1)"

.PP
Definition at line 165 of file kinetic_session\&.c\&.
.SH "Function Documentation"
.PP 
.SS "\fBKineticStatus\fP KineticSession_Create (KineticSession *constsession, KineticClient *constclient)"

.PP
Definition at line 37 of file kinetic_session\&.c\&.
.PP
References KINETIC_MAX_OUTSTANDING_OPERATIONS_PER_SESSION, KINETIC_SOCKET_INVALID, KINETIC_STATUS_MEMORY_ERROR, KINETIC_STATUS_SESSION_EMPTY, KINETIC_STATUS_SUCCESS, KineticCountingSemaphore_Create(), and LOG0\&.
.SS "\fBKineticStatus\fP KineticSession_Destroy (KineticSession *constsession)"

.PP
Definition at line 68 of file kinetic_session\&.c\&.
.PP
References KINETIC_STATUS_SESSION_EMPTY, KINETIC_STATUS_SUCCESS, KineticAllocator_FreeSession(), and KineticCountingSemaphore_Destroy()\&.
.SS "\fBKineticStatus\fP KineticSession_Connect (KineticSession *constsession)"

.PP
Definition at line 79 of file kinetic_session\&.c\&.
.PP
References Bus_RegisterSocket(), BUS_SOCKET_PLAIN, BUS_SOCKET_SSL, KINETIC_ASSERT, KINETIC_CONNECTION_TIMEOUT_SECS, KINETIC_SOCKET_DESCRIPTOR_INVALID, KINETIC_STATUS_CONNECTION_ERROR, KINETIC_STATUS_MEMORY_ERROR, KINETIC_STATUS_SESSION_EMPTY, KINETIC_STATUS_SUCCESS, KineticResourceWaiter_WaitTilAvailable(), KineticSession_GetConnectionID(), KineticSocket_Close(), KineticSocket_Connect(), LOG0, LOGF1, and PDU_PROTO_MAX_LEN\&.
.SS "\fBKineticStatus\fP KineticSession_Disconnect (KineticSession *constsession)"

.PP
Definition at line 131 of file kinetic_session\&.c\&.
.PP
References Bus_ReleaseSocket(), KINETIC_SOCKET_INVALID, KINETIC_STATUS_CONNECTION_ERROR, KINETIC_STATUS_SESSION_EMPTY, and KINETIC_STATUS_SUCCESS\&.
.SS "\fBKineticStatus\fP KineticSession_GetTerminationStatus (KineticSession const *constsession)"

.PP
Definition at line 151 of file kinetic_session\&.c\&.
.PP
References KINETIC_STATUS_SESSION_INVALID\&.
.SS "void KineticSession_SetTerminationStatus (KineticSession *constsession, \fBKineticStatus\fPstatus)"

.PP
Definition at line 159 of file kinetic_session\&.c\&.
.PP
References KINETIC_ASSERT\&.
.SS "int64_t KineticSession_GetNextSequenceCount (KineticSession *constsession)"

.PP
Definition at line 167 of file kinetic_session\&.c\&.
.PP
References ATOMIC_FETCH_AND_INCREMENT, and KINETIC_ASSERT\&.
.SS "int64_t KineticSession_GetClusterVersion (KineticSession const *constsession)"

.PP
Definition at line 174 of file kinetic_session\&.c\&.
.PP
References KINETIC_ASSERT\&.
.SS "void KineticSession_SetClusterVersion (KineticSession *constsession, int64_tcluster_version)"

.PP
Definition at line 180 of file kinetic_session\&.c\&.
.PP
References KINETIC_ASSERT\&.
.SS "int64_t KineticSession_GetConnectionID (KineticSession const *constsession)"

.PP
Definition at line 186 of file kinetic_session\&.c\&.
.PP
References KINETIC_ASSERT\&.
.SS "void KineticSession_SetConnectionID (KineticSession *constsession, int64_tid)"

.PP
Definition at line 192 of file kinetic_session\&.c\&.
.PP
References KINETIC_ASSERT\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for kinetic-c from the source code\&.
