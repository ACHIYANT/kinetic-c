.TH "kinetic_client.c" 3 "Tue Nov 4 2014" "Version v0.8.0" "kinetic-c" \" -*- nroff -*-
.ad l
.nh
.SH NAME
kinetic_client.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'kinetic_client\&.h'\fP
.br
\fC#include 'kinetic_types_internal\&.h'\fP
.br
\fC#include 'kinetic_pdu\&.h'\fP
.br
\fC#include 'kinetic_operation\&.h'\fP
.br
\fC#include 'kinetic_connection\&.h'\fP
.br
\fC#include 'kinetic_message\&.h'\fP
.br
\fC#include 'kinetic_allocator\&.h'\fP
.br
\fC#include 'kinetic_logger\&.h'\fP
.br
\fC#include <stdlib\&.h>\fP
.br
\fC#include <sys/time\&.h>\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBKineticClient_Init\fP (const char *log_file, int log_level)"
.br
.RI "\fIInitializes the Kinetic API andcsonfigures logging destination\&. \fP"
.ti -1c
.RI "void \fBKineticClient_Shutdown\fP (void)"
.br
.RI "\fIPerforms shutdown/cleanup of the kinetic-c client lib\&. \fP"
.ti -1c
.RI "\fBKineticStatus\fP \fBKineticClient_Connect\fP (const \fBKineticSession\fP *config, \fBKineticSessionHandle\fP *handle)"
.br
.RI "\fIInitializes the Kinetic API, configures logging destination, establishes a connection to the specified Kinetic Device, and establishes a session\&. \fP"
.ti -1c
.RI "\fBKineticStatus\fP \fBKineticClient_Disconnect\fP (\fBKineticSessionHandle\fP *const handle)"
.br
.RI "\fICloses the connection to a host\&. \fP"
.ti -1c
.RI "\fBKineticStatus\fP \fBKineticClient_NoOp\fP (\fBKineticSessionHandle\fP handle)"
.br
.RI "\fIExecutes a NOOP command to test whether the Kinetic Device is operational\&. \fP"
.ti -1c
.RI "\fBKineticStatus\fP \fBKineticClient_Put\fP (\fBKineticSessionHandle\fP handle, \fBKineticEntry\fP *const entry, \fBKineticCompletionClosure\fP *closure)"
.br
.RI "\fIExecutes a PUT command to store/update an entry on the Kinetic Device\&. \fP"
.ti -1c
.RI "\fBKineticStatus\fP \fBKineticClient_Get\fP (\fBKineticSessionHandle\fP handle, \fBKineticEntry\fP *const entry, \fBKineticCompletionClosure\fP *closure)"
.br
.RI "\fIExecutes a GET command to retrieve and entry from the Kinetic Device\&. \fP"
.ti -1c
.RI "\fBKineticStatus\fP \fBKineticClient_Delete\fP (\fBKineticSessionHandle\fP handle, \fBKineticEntry\fP *const entry, \fBKineticCompletionClosure\fP *closure)"
.br
.RI "\fIExecutes a DELETE command to delete an entry from the Kinetic Device\&. \fP"
.ti -1c
.RI "\fBKineticStatus\fP \fBKineticClient_GetKeyRange\fP (\fBKineticSessionHandle\fP handle, \fBKineticKeyRange\fP *range, \fBByteBufferArray\fP *keys, \fBKineticCompletionClosure\fP *closure)"
.br
.RI "\fIExecutes a GETKEYRANGE command to retrive a set of keys in the range specified range from the Kinetic Device\&. \fP"
.in -1c
.SH "Function Documentation"
.PP 
.SS "void KineticClient_Init (const char *log_file, intlog_level)"

.PP
Initializes the Kinetic API andcsonfigures logging destination\&. 
.PP
\fBParameters:\fP
.RS 4
\fIlog_file\fP (path to log file, 'stdout' to log to STDOUT, NULL to disable logging) 
.br
\fIlog_level\fP Logging level (-1:none, 0:error, 1:info, 2:verbose, 3:full) 
.RE
.PP

.PP
Definition at line 89 of file kinetic_client\&.c\&.
.PP
References KineticLogger_Init()\&.
.SS "void KineticClient_Shutdown (void)"

.PP
Performs shutdown/cleanup of the kinetic-c client lib\&. 
.PP
Definition at line 94 of file kinetic_client\&.c\&.
.PP
References KineticLogger_Close()\&.
.SS "\fBKineticStatus\fP KineticClient_Connect (const \fBKineticSession\fP *config, \fBKineticSessionHandle\fP *handle)"

.PP
Initializes the Kinetic API, configures logging destination, establishes a connection to the specified Kinetic Device, and establishes a session\&. 
.PP
\fBParameters:\fP
.RS 4
\fIconfig\fP Session configuration \&.host Host name or IP address to connect to \&.port Port to establish socket connection on \&.nonBlocking Set to true for non-blocking or false for blocking I/O \&.clusterVersion Cluster version to use for the session \&.identity Identity to use for the session \&.hmacKey Key to use for HMAC calculations (NULL-terminated string) 
.br
\fIhandle\fP Pointer to KineticSessionHandle (populated upon successful connection)
.RE
.PP
\fBReturns:\fP
.RS 4
Returns the resulting KineticStatus 
.RE
.PP

.PP
Definition at line 99 of file kinetic_client\&.c\&.
.PP
References ByteArray::data, KineticSession::hmacKey, KineticSession::host, KINETIC_HANDLE_INVALID, KINETIC_STATUS_CONNECTION_ERROR, KINETIC_STATUS_HMAC_EMPTY, KINETIC_STATUS_HOST_EMPTY, KINETIC_STATUS_SESSION_EMPTY, KINETIC_STATUS_SESSION_INVALID, KINETIC_STATUS_SUCCESS, KineticConnection_Connect(), KineticConnection_FreeConnection(), KineticConnection_FromHandle(), KineticConnection_NewConnection(), ByteArray::len, LOG0, LOGF0, and KineticSession::port\&.
.SS "\fBKineticStatus\fP KineticClient_Disconnect (\fBKineticSessionHandle\fP *consthandle)"

.PP
Closes the connection to a host\&. 
.PP
\fBParameters:\fP
.RS 4
\fIhandle\fP KineticSessionHandle for a connected session\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Returns the resulting KineticStatus 
.RE
.PP

.PP
Definition at line 150 of file kinetic_client\&.c\&.
.PP
References KINETIC_HANDLE_INVALID, KINETIC_STATUS_CONNECTION_ERROR, KINETIC_STATUS_SESSION_INVALID, KINETIC_STATUS_SUCCESS, KineticConnection_Disconnect(), KineticConnection_FreeConnection(), KineticConnection_FromHandle(), and LOG0\&.
.SS "\fBKineticStatus\fP KineticClient_NoOp (\fBKineticSessionHandle\fPhandle)"

.PP
Executes a NOOP command to test whether the Kinetic Device is operational\&. 
.PP
\fBParameters:\fP
.RS 4
\fIhandle\fP KineticSessionHandle for a connected session\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Returns the resulting KineticStatus 
.RE
.PP

.PP
Definition at line 171 of file kinetic_client\&.c\&.
.PP
References KINETIC_STATUS_SUCCESS, and KineticOperation_BuildNoop()\&.
.SS "\fBKineticStatus\fP KineticClient_Put (\fBKineticSessionHandle\fPhandle, \fBKineticEntry\fP *constentry, \fBKineticCompletionClosure\fP *closure)"

.PP
Executes a PUT command to store/update an entry on the Kinetic Device\&. 
.PP
\fBParameters:\fP
.RS 4
\fIhandle\fP KineticSessionHandle for a connected session\&. 
.br
\fIentry\fP Key/value entry for object to store\&. 'value' must specify the data to be stored\&. 
.br
\fIclosure\fP Optional closure\&. If specified, operation will be executed in asynchronous mode, and closure callback will be called upon completion\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Returns the resulting KineticStatus 
.RE
.PP

.PP
Definition at line 187 of file kinetic_client\&.c\&.
.PP
References ByteBuffer::array, ByteArray::data, KINETIC_STATUS_SUCCESS, KineticOperation_BuildPut(), and KineticEntry::value\&.
.SS "\fBKineticStatus\fP KineticClient_Get (\fBKineticSessionHandle\fPhandle, \fBKineticEntry\fP *constentry, \fBKineticCompletionClosure\fP *closure)"

.PP
Executes a GET command to retrieve and entry from the Kinetic Device\&. 
.PP
\fBParameters:\fP
.RS 4
\fIhandle\fP KineticSessionHandle for a connected session\&. 
.br
\fIentry\fP Key/value entry for object to retrieve\&. 'value' will be populated unless 'metadataOnly' is set to 'true'\&. 
.br
\fIclosure\fP Optional closure\&. If specified, operation will be executed in asynchronous mode, and closure callback will be called upon completion\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Returns the resulting KineticStatus 
.RE
.PP

.PP
Definition at line 206 of file kinetic_client\&.c\&.
.PP
References ByteBuffer::array, ByteArray::data, KINETIC_STATUS_SUCCESS, KineticOperation_BuildGet(), KineticEntry::metadataOnly, and KineticEntry::value\&.
.SS "\fBKineticStatus\fP KineticClient_Delete (\fBKineticSessionHandle\fPhandle, \fBKineticEntry\fP *constentry, \fBKineticCompletionClosure\fP *closure)"

.PP
Executes a DELETE command to delete an entry from the Kinetic Device\&. 
.PP
\fBParameters:\fP
.RS 4
\fIhandle\fP KineticSessionHandle for a connected session\&. 
.br
\fIentry\fP Key/value entry for object to delete\&. 'value' is not used for this operation\&. 
.br
\fIclosure\fP Optional closure\&. If specified, operation will be executed in asynchronous mode, and closure callback will be called upon completion\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Returns the resulting KineticStatus 
.RE
.PP

.PP
Definition at line 225 of file kinetic_client\&.c\&.
.PP
References KINETIC_STATUS_SUCCESS, and KineticOperation_BuildDelete()\&.
.SS "\fBKineticStatus\fP KineticClient_GetKeyRange (\fBKineticSessionHandle\fPhandle, \fBKineticKeyRange\fP *range, \fBByteBufferArray\fP *keys, \fBKineticCompletionClosure\fP *closure)"

.PP
Executes a GETKEYRANGE command to retrive a set of keys in the range specified range from the Kinetic Device\&. 
.PP
\fBParameters:\fP
.RS 4
\fIhandle\fP KineticSessionHandle for a connected session 
.br
\fIrange\fP \fBKineticKeyRange\fP specifying keys to return 
.br
\fIkeys\fP \fBByteBufferArray\fP to store the retrieved keys 
.br
\fIclosure\fP Optional closure\&. If specified, operation will be executed in asynchronous mode, and closure callback will be called upon completion\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Returns 0 upon succes, -1 or the Kinetic status code upon failure 
.RE
.PP

.PP
Definition at line 243 of file kinetic_client\&.c\&.
.PP
References ByteBufferArray::buffers, ByteBufferArray::count, KINETIC_HANDLE_INVALID, KINETIC_STATUS_SUCCESS, and KineticOperation_BuildGetKeyRange()\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for kinetic-c from the source code\&.
