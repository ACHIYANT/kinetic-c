.TH "kinetic_operation.c" 3 "Wed Feb 11 2015" "Version v0.11.1" "kinetic-c" \" -*- nroff -*-
.ad l
.nh
.SH NAME
kinetic_operation.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'kinetic_operation\&.h'\fP
.br
\fC#include 'kinetic_controller\&.h'\fP
.br
\fC#include 'kinetic_session\&.h'\fP
.br
\fC#include 'kinetic_message\&.h'\fP
.br
\fC#include 'kinetic_pdu\&.h'\fP
.br
\fC#include 'kinetic_nbo\&.h'\fP
.br
\fC#include 'kinetic_socket\&.h'\fP
.br
\fC#include 'kinetic_device_info\&.h'\fP
.br
\fC#include 'kinetic_allocator\&.h'\fP
.br
\fC#include 'kinetic_logger\&.h'\fP
.br
\fC#include <pthread\&.h>\fP
.br
\fC#include <stdlib\&.h>\fP
.br
\fC#include <errno\&.h>\fP
.br
\fC#include <sys/time\&.h>\fP
.br
\fC#include 'bus\&.h'\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBATOMIC_FETCH_AND_INCREMENT\fP(P)   __sync_fetch_and_add(P, 1)"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBKineticStatus\fP \fBKineticOperation_SendRequest\fP (KineticOperation *const operation)"
.br
.ti -1c
.RI "\fBKineticStatus\fP \fBKineticOperation_GetStatus\fP (const KineticOperation *const operation)"
.br
.ti -1c
.RI "\fBKineticStatus\fP \fBKineticOperation_NoopCallback\fP (KineticOperation *const operation, \fBKineticStatus\fP const status)"
.br
.ti -1c
.RI "void \fBKineticOperation_BuildNoop\fP (KineticOperation *const operation)"
.br
.ti -1c
.RI "\fBKineticStatus\fP \fBKineticOperation_PutCallback\fP (KineticOperation *const operation, \fBKineticStatus\fP const status)"
.br
.ti -1c
.RI "void \fBKineticOperation_BuildPut\fP (KineticOperation *const operation, \fBKineticEntry\fP *const entry)"
.br
.ti -1c
.RI "void \fBKineticOperation_BuildGet\fP (KineticOperation *const operation, \fBKineticEntry\fP *const entry)"
.br
.ti -1c
.RI "void \fBKineticOperation_BuildGetPrevious\fP (KineticOperation *const operation, \fBKineticEntry\fP *const entry)"
.br
.ti -1c
.RI "void \fBKineticOperation_BuildGetNext\fP (KineticOperation *const operation, \fBKineticEntry\fP *const entry)"
.br
.ti -1c
.RI "\fBKineticStatus\fP \fBKineticOperation_FlushCallback\fP (KineticOperation *const operation, \fBKineticStatus\fP const status)"
.br
.ti -1c
.RI "void \fBKineticOperation_BuildFlush\fP (KineticOperation *const operation)"
.br
.ti -1c
.RI "\fBKineticStatus\fP \fBKineticOperation_DeleteCallback\fP (KineticOperation *const operation, \fBKineticStatus\fP const status)"
.br
.ti -1c
.RI "void \fBKineticOperation_BuildDelete\fP (KineticOperation *const operation, \fBKineticEntry\fP *const entry)"
.br
.ti -1c
.RI "\fBKineticStatus\fP \fBKineticOperation_GetKeyRangeCallback\fP (KineticOperation *const operation, \fBKineticStatus\fP const status)"
.br
.ti -1c
.RI "void \fBKineticOperation_BuildGetKeyRange\fP (KineticOperation *const operation, \fBKineticKeyRange\fP *range, \fBByteBufferArray\fP *buffers)"
.br
.ti -1c
.RI "\fBKineticStatus\fP \fBKineticOperation_GetLogCallback\fP (KineticOperation *const operation, \fBKineticStatus\fP const status)"
.br
.ti -1c
.RI "void \fBKineticOperation_BuildGetLog\fP (KineticOperation *const operation, \fBKineticDeviceInfo_Type\fP type, \fBKineticDeviceInfo\fP **info)"
.br
.ti -1c
.RI "void \fBdestroy_p2pOp\fP (KineticProto_Command_P2POperation *proto_p2pOp)"
.br
.ti -1c
.RI "KineticProto_Command_P2POperation * \fBbuild_p2pOp\fP (uint32_t nestingLevel, KineticP2P_Operation const *const p2pOp)"
.br
.ti -1c
.RI "\fBKineticStatus\fP \fBKineticOperation_P2POperationCallback\fP (KineticOperation *const operation, \fBKineticStatus\fP const status)"
.br
.ti -1c
.RI "\fBKineticStatus\fP \fBKineticOperation_BuildP2POperation\fP (KineticOperation *const operation, KineticP2P_Operation *const p2pOp)"
.br
.ti -1c
.RI "\fBKineticStatus\fP \fBKineticOperation_InstantSecureEraseCallback\fP (KineticOperation *const operation, \fBKineticStatus\fP const status)"
.br
.ti -1c
.RI "void \fBKineticOperation_BuildInstantSecureErase\fP (KineticOperation *operation)"
.br
.ti -1c
.RI "\fBKineticStatus\fP \fBKineticOperation_SetClusterVersionCallback\fP (KineticOperation *operation, \fBKineticStatus\fP const status)"
.br
.ti -1c
.RI "void \fBKineticOperation_BuildSetClusterVersion\fP (KineticOperation *operation, int64_t newClusterVersion)"
.br
.ti -1c
.RI "void \fBKineticOperation_Complete\fP (KineticOperation *operation, \fBKineticStatus\fP status)"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define ATOMIC_FETCH_AND_INCREMENT(P)   __sync_fetch_and_add(P, 1)"

.PP
Definition at line 37 of file kinetic_operation\&.c\&.
.SH "Function Documentation"
.PP 
.SS "\fBKineticStatus\fP KineticOperation_SendRequest (KineticOperation *constoperation)"

.PP
Definition at line 42 of file kinetic_operation\&.c\&.
.PP
References KINETIC_STATUS_SUCCESS\&.
.SS "\fBKineticStatus\fP KineticOperation_GetStatus (const KineticOperation *constoperation)"

.PP
Definition at line 220 of file kinetic_operation\&.c\&.
.PP
References KINETIC_STATUS_INVALID, and KineticPDU_GetStatus()\&.
.SS "\fBKineticStatus\fP KineticOperation_NoopCallback (KineticOperation *constoperation, \fBKineticStatus\fP conststatus)"

.PP
Definition at line 229 of file kinetic_operation\&.c\&.
.PP
References LOGF3\&.
.SS "void KineticOperation_BuildNoop (KineticOperation *constoperation)"

.PP
Definition at line 238 of file kinetic_operation\&.c\&.
.PP
References KINETIC_PROTO_COMMAND_MESSAGE_TYPE_NOOP, and KineticOperation_NoopCallback()\&.
.SS "\fBKineticStatus\fP KineticOperation_PutCallback (KineticOperation *constoperation, \fBKineticStatus\fP conststatus)"

.PP
Definition at line 249 of file kinetic_operation\&.c\&.
.PP
References ByteBuffer::array, BYTE_BUFFER_NONE, ByteBuffer_Append(), ByteBuffer_Reset(), ByteBuffer::bytesUsed, ByteArray::data, KineticEntry::dbVersion, KINETIC_STATUS_SUCCESS, ByteArray::len, LOGF3, and KineticEntry::newVersion\&.
.SS "void KineticOperation_BuildPut (KineticOperation *constoperation, \fBKineticEntry\fP *constentry)"

.PP
Definition at line 281 of file kinetic_operation\&.c\&.
.PP
References KINETIC_PROTO_COMMAND_MESSAGE_TYPE_PUT, KineticMessage_ConfigureKeyValue(), and KineticOperation_PutCallback()\&.
.SS "void KineticOperation_BuildGet (KineticOperation *constoperation, \fBKineticEntry\fP *constentry)"

.PP
Definition at line 356 of file kinetic_operation\&.c\&.
.PP
References KINETIC_PROTO_COMMAND_MESSAGE_TYPE_GET\&.
.SS "void KineticOperation_BuildGetPrevious (KineticOperation *constoperation, \fBKineticEntry\fP *constentry)"

.PP
Definition at line 368 of file kinetic_operation\&.c\&.
.PP
References KINETIC_PROTO_COMMAND_MESSAGE_TYPE_GETPREVIOUS\&.
.SS "void KineticOperation_BuildGetNext (KineticOperation *constoperation, \fBKineticEntry\fP *constentry)"

.PP
Definition at line 380 of file kinetic_operation\&.c\&.
.PP
References KINETIC_PROTO_COMMAND_MESSAGE_TYPE_GETNEXT\&.
.SS "\fBKineticStatus\fP KineticOperation_FlushCallback (KineticOperation *constoperation, \fBKineticStatus\fP conststatus)"

.PP
Definition at line 387 of file kinetic_operation\&.c\&.
.PP
References LOGF3\&.
.SS "void KineticOperation_BuildFlush (KineticOperation *constoperation)"

.PP
Definition at line 397 of file kinetic_operation\&.c\&.
.PP
References KINETIC_PROTO_COMMAND_MESSAGE_TYPE_FLUSHALLDATA, and KineticOperation_FlushCallback()\&.
.SS "\fBKineticStatus\fP KineticOperation_DeleteCallback (KineticOperation *constoperation, \fBKineticStatus\fP conststatus)"

.PP
Definition at line 408 of file kinetic_operation\&.c\&.
.PP
References LOGF3\&.
.SS "void KineticOperation_BuildDelete (KineticOperation *constoperation, \fBKineticEntry\fP *constentry)"

.PP
Definition at line 418 of file kinetic_operation\&.c\&.
.PP
References ByteBuffer_Reset(), KINETIC_PROTO_COMMAND_MESSAGE_TYPE_DELETE, KineticMessage_ConfigureKeyValue(), and KineticOperation_DeleteCallback()\&.
.SS "\fBKineticStatus\fP KineticOperation_GetKeyRangeCallback (KineticOperation *constoperation, \fBKineticStatus\fP conststatus)"

.PP
Definition at line 438 of file kinetic_operation\&.c\&.
.PP
References Copy_KineticProto_Command_Range_to_ByteBufferArray(), KINETIC_STATUS_BUFFER_OVERRUN, KINETIC_STATUS_SUCCESS, KineticPDU_GetKeyRange(), and LOGF3\&.
.SS "void KineticOperation_BuildGetKeyRange (KineticOperation *constoperation, \fBKineticKeyRange\fP *range, \fBByteBufferArray\fP *buffers)"

.PP
Definition at line 461 of file kinetic_operation\&.c\&.
.PP
References KINETIC_PROTO_COMMAND_MESSAGE_TYPE_GETKEYRANGE, KineticMessage_ConfigureKeyRange(), and KineticOperation_GetKeyRangeCallback()\&.
.SS "\fBKineticStatus\fP KineticOperation_GetLogCallback (KineticOperation *constoperation, \fBKineticStatus\fP conststatus)"

.PP
Definition at line 479 of file kinetic_operation\&.c\&.
.PP
References KINETIC_STATUS_OPERATION_FAILED, KINETIC_STATUS_SUCCESS, KineticDeviceInfo_Create(), and LOGF3\&.
.SS "void KineticOperation_BuildGetLog (KineticOperation *constoperation, \fBKineticDeviceInfo_Type\fPtype, \fBKineticDeviceInfo\fP **info)"

.PP
Definition at line 502 of file kinetic_operation\&.c\&.
.PP
References KINETIC_PROTO_COMMAND_MESSAGE_TYPE_GETLOG, KineticDeviceInfo_Type_to_KineticProto_Command_GetLog_Type(), and KineticOperation_GetLogCallback()\&.
.SS "void destroy_p2pOp (KineticProto_Command_P2POperation *proto_p2pOp)"

.PP
Definition at line 522 of file kinetic_operation\&.c\&.
.SS "KineticProto_Command_P2POperation* build_p2pOp (uint32_tnestingLevel, KineticP2P_Operation const *constp2pOp)"

.PP
Definition at line 552 of file kinetic_operation\&.c\&.
.PP
References ByteBuffer_IsNull(), destroy_p2pOp(), KineticProto_command_p2_poperation__init(), KineticProto_command_p2_poperation_operation__init(), KineticProto_command_p2_poperation_peer__init(), and LOG0\&.
.SS "\fBKineticStatus\fP KineticOperation_P2POperationCallback (KineticOperation *constoperation, \fBKineticStatus\fP conststatus)"

.PP
Definition at line 652 of file kinetic_operation\&.c\&.
.PP
References destroy_p2pOp(), and KINETIC_STATUS_SUCCESS\&.
.SS "\fBKineticStatus\fP KineticOperation_BuildP2POperation (KineticOperation *constoperation, KineticP2P_Operation *constp2pOp)"

.PP
Definition at line 671 of file kinetic_operation\&.c\&.
.PP
References build_p2pOp(), KINETIC_PROTO_COMMAND_MESSAGE_TYPE_PEER2PEERPUSH, KINETIC_STATUS_BUFFER_OVERRUN, KINETIC_STATUS_OPERATION_INVALID, KINETIC_STATUS_SUCCESS, and KineticOperation_P2POperationCallback()\&.
.SS "\fBKineticStatus\fP KineticOperation_InstantSecureEraseCallback (KineticOperation *constoperation, \fBKineticStatus\fP conststatus)"

.PP
Definition at line 695 of file kinetic_operation\&.c\&.
.PP
References LOGF3\&.
.SS "void KineticOperation_BuildInstantSecureErase (KineticOperation *operation)"

.PP
Definition at line 704 of file kinetic_operation\&.c\&.
.PP
References KINETIC_PROTO_COMMAND_MESSAGE_TYPE_SETUP, KINETIC_PROTO_COMMAND_PIN_OPERATION_PIN_OP_TYPE_SECURE_ERASE_PINOP, and KineticOperation_InstantSecureEraseCallback()\&.
.SS "\fBKineticStatus\fP KineticOperation_SetClusterVersionCallback (KineticOperation *operation, \fBKineticStatus\fP conststatus)"

.PP
Definition at line 720 of file kinetic_operation\&.c\&.
.PP
References KINETIC_STATUS_SUCCESS, and LOGF3\&.
.SS "void KineticOperation_BuildSetClusterVersion (KineticOperation *operation, int64_tnewClusterVersion)"

.PP
Definition at line 731 of file kinetic_operation\&.c\&.
.PP
References KINETIC_PROTO_COMMAND_MESSAGE_TYPE_SETUP, and KineticOperation_SetClusterVersionCallback()\&.
.SS "void KineticOperation_Complete (KineticOperation *operation, \fBKineticStatus\fPstatus)"

.PP
Definition at line 757 of file kinetic_operation\&.c\&.
.PP
References KineticAllocator_FreeOperation(), KineticCountingSemaphore_Give(), and KineticCompletionData::status\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for kinetic-c from the source code\&.
