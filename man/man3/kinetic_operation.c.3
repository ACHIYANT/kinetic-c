.TH "kinetic_operation.c" 3 "Tue Mar 3 2015" "Version v0.12.0-beta" "kinetic-c" \" -*- nroff -*-
.ad l
.nh
.SH NAME
kinetic_operation.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'kinetic_operation\&.h'\fP
.br
\fC#include 'kinetic_controller\&.h'\fP
.br
\fC#include 'kinetic_session\&.h'\fP
.br
\fC#include 'kinetic_message\&.h'\fP
.br
\fC#include 'kinetic_bus\&.h'\fP
.br
\fC#include 'kinetic_response\&.h'\fP
.br
\fC#include 'kinetic_device_info\&.h'\fP
.br
\fC#include 'kinetic_allocator\&.h'\fP
.br
\fC#include 'kinetic_logger\&.h'\fP
.br
\fC#include 'kinetic_request\&.h'\fP
.br
\fC#include <stdlib\&.h>\fP
.br
\fC#include <errno\&.h>\fP
.br
\fC#include <sys/time\&.h>\fP
.br
\fC#include <stdio\&.h>\fP
.br
\fC#include 'acl\&.h'\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBATOMIC_FETCH_AND_INCREMENT\fP(P)   __sync_fetch_and_add(P, 1)"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "static void \fBKineticOperation_ValidateOperation\fP (KineticOperation *operation)"
.br
.ti -1c
.RI "static \fBKineticStatus\fP \fBKineticOperation_SendRequestInLock\fP (KineticOperation *const operation)"
.br
.ti -1c
.RI "\fBKineticStatus\fP \fBKineticOperation_SendRequest\fP (KineticOperation *const operation)"
.br
.ti -1c
.RI "static void \fBlog_request_seq_id\fP (int fd, int64_t seq_id, \fBKineticMessageType\fP mt)"
.br
.ti -1c
.RI "\fBKineticStatus\fP \fBKineticOperation_GetStatus\fP (const KineticOperation *const operation)"
.br
.ti -1c
.RI "void \fBKineticOperation_Complete\fP (KineticOperation *operation, \fBKineticStatus\fP status)"
.br
.ti -1c
.RI "\fBKineticStatus\fP \fBKineticOperation_NoopCallback\fP (KineticOperation *const operation, \fBKineticStatus\fP const status)"
.br
.ti -1c
.RI "void \fBKineticOperation_BuildNoop\fP (KineticOperation *const operation)"
.br
.ti -1c
.RI "\fBKineticStatus\fP \fBKineticOperation_PutCallback\fP (KineticOperation *const operation, \fBKineticStatus\fP const status)"
.br
.ti -1c
.RI "\fBKineticStatus\fP \fBKineticOperation_BuildPut\fP (KineticOperation *const operation, \fBKineticEntry\fP *const entry)"
.br
.ti -1c
.RI "static \fBKineticStatus\fP \fBget_cb\fP (const char *cmd_name, KineticOperation *const operation, \fBKineticStatus\fP const status)"
.br
.ti -1c
.RI "static void \fBbuild_get_command\fP (KineticOperation *const operation, \fBKineticEntry\fP *const entry, \fBKineticOperationCallback\fP cb, \fBKineticProto_Command_MessageType\fP command_id)"
.br
.ti -1c
.RI "static \fBKineticStatus\fP \fBget_cmd_cb\fP (KineticOperation *const operation, \fBKineticStatus\fP const status)"
.br
.ti -1c
.RI "void \fBKineticOperation_BuildGet\fP (KineticOperation *const operation, \fBKineticEntry\fP *const entry)"
.br
.ti -1c
.RI "static \fBKineticStatus\fP \fBgetprevious_cmd_cb\fP (KineticOperation *const operation, \fBKineticStatus\fP const status)"
.br
.ti -1c
.RI "void \fBKineticOperation_BuildGetPrevious\fP (KineticOperation *const operation, \fBKineticEntry\fP *const entry)"
.br
.ti -1c
.RI "static \fBKineticStatus\fP \fBgetnext_cmd_cb\fP (KineticOperation *const operation, \fBKineticStatus\fP const status)"
.br
.ti -1c
.RI "void \fBKineticOperation_BuildGetNext\fP (KineticOperation *const operation, \fBKineticEntry\fP *const entry)"
.br
.ti -1c
.RI "\fBKineticStatus\fP \fBKineticOperation_FlushCallback\fP (KineticOperation *const operation, \fBKineticStatus\fP const status)"
.br
.ti -1c
.RI "void \fBKineticOperation_BuildFlush\fP (KineticOperation *const operation)"
.br
.ti -1c
.RI "\fBKineticStatus\fP \fBKineticOperation_DeleteCallback\fP (KineticOperation *const operation, \fBKineticStatus\fP const status)"
.br
.ti -1c
.RI "void \fBKineticOperation_BuildDelete\fP (KineticOperation *const operation, \fBKineticEntry\fP *const entry)"
.br
.ti -1c
.RI "\fBKineticStatus\fP \fBKineticOperation_GetKeyRangeCallback\fP (KineticOperation *const operation, \fBKineticStatus\fP const status)"
.br
.ti -1c
.RI "void \fBKineticOperation_BuildGetKeyRange\fP (KineticOperation *const operation, \fBKineticKeyRange\fP *range, \fBByteBufferArray\fP *buffers)"
.br
.ti -1c
.RI "\fBKineticStatus\fP \fBKineticOperation_GetLogCallback\fP (KineticOperation *const operation, \fBKineticStatus\fP const status)"
.br
.ti -1c
.RI "void \fBKineticOperation_BuildGetLog\fP (KineticOperation *const operation, \fBKineticLogInfo_Type\fP type, \fBKineticLogInfo\fP **info)"
.br
.ti -1c
.RI "void \fBdestroy_p2pOp\fP (KineticProto_Command_P2POperation *proto_p2pOp)"
.br
.ti -1c
.RI "KineticProto_Command_P2POperation * \fBbuild_p2pOp\fP (uint32_t nestingLevel, KineticP2P_Operation const *const p2pOp)"
.br
.ti -1c
.RI "static void \fBpopulateP2PStatusCodes\fP (KineticP2P_Operation *const p2pOp, KineticProto_Command_P2POperation const *const p2pOperation)"
.br
.ti -1c
.RI "\fBKineticStatus\fP \fBKineticOperation_P2POperationCallback\fP (KineticOperation *const operation, \fBKineticStatus\fP const status)"
.br
.ti -1c
.RI "\fBKineticStatus\fP \fBKineticOperation_BuildP2POperation\fP (KineticOperation *const operation, KineticP2P_Operation *const p2pOp)"
.br
.ti -1c
.RI "\fBKineticStatus\fP \fBKineticOperation_SetPinCallback\fP (KineticOperation *const operation, \fBKineticStatus\fP const status)"
.br
.ti -1c
.RI "void \fBKineticOperation_BuildSetPin\fP (KineticOperation *const operation, \fBByteArray\fP old_pin, \fBByteArray\fP new_pin, bool lock)"
.br
.ti -1c
.RI "\fBKineticStatus\fP \fBKineticOperation_EraseCallback\fP (KineticOperation *const operation, \fBKineticStatus\fP const status)"
.br
.ti -1c
.RI "void \fBKineticOperation_BuildErase\fP (KineticOperation *const operation, bool secure_erase, \fBByteArray\fP *pin)"
.br
.ti -1c
.RI "\fBKineticStatus\fP \fBKineticOperation_LockUnlockCallback\fP (KineticOperation *const operation, \fBKineticStatus\fP const status)"
.br
.ti -1c
.RI "void \fBKineticOperation_BuildLockUnlock\fP (KineticOperation *const operation, bool lock, \fBByteArray\fP *pin)"
.br
.ti -1c
.RI "\fBKineticStatus\fP \fBKineticOperation_SetClusterVersionCallback\fP (KineticOperation *const operation, \fBKineticStatus\fP const status)"
.br
.ti -1c
.RI "void \fBKineticOperation_BuildSetClusterVersion\fP (KineticOperation *operation, int64_t new_cluster_version)"
.br
.ti -1c
.RI "\fBKineticStatus\fP \fBKineticOperation_SetACLCallback\fP (KineticOperation *const operation, \fBKineticStatus\fP const status)"
.br
.ti -1c
.RI "void \fBKineticOperation_BuildSetACL\fP (KineticOperation *const operation, struct \fBACL\fP *ACLs)"
.br
.ti -1c
.RI "\fBKineticStatus\fP \fBKineticOperation_UpdateFirmwareCallback\fP (KineticOperation *const operation, \fBKineticStatus\fP const status)"
.br
.ti -1c
.RI "\fBKineticStatus\fP \fBKineticOperation_BuildUpdateFirmware\fP (KineticOperation *const operation, const char *fw_path)"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define ATOMIC_FETCH_AND_INCREMENT(P)   __sync_fetch_and_add(P, 1)"

.PP
Definition at line 38 of file kinetic_operation\&.c\&.
.SH "Function Documentation"
.PP 
.SS "static void KineticOperation_ValidateOperation (KineticOperation *operation)\fC [static]\fP"

.PP
Definition at line 152 of file kinetic_operation\&.c\&.
.PP
References KINETIC_ASSERT\&.
.SS "static \fBKineticStatus\fP KineticOperation_SendRequestInLock (KineticOperation *constoperation)\fC [static]\fP"

.PP
Definition at line 84 of file kinetic_operation\&.c\&.
.PP
References KINETIC_ASSERT, KINETIC_REQUEST_PACK_FAILURE, KINETIC_SEQUENCE_NOT_YET_BOUND, KINETIC_STATUS_MEMORY_ERROR, KINETIC_STATUS_REQUEST_REJECTED, KINETIC_STATUS_SUCCESS, KineticCountingSemaphore_Give(), KineticCountingSemaphore_Take(), KineticRequest_PackCommand(), KineticRequest_PackMessage(), KineticRequest_PopulateAuthentication(), KineticRequest_SendRequest(), KineticSession_GetNextSequenceCount(), log_request_seq_id(), LOGF0, and LOGF3\&.
.SS "\fBKineticStatus\fP KineticOperation_SendRequest (KineticOperation *constoperation)"

.PP
Definition at line 48 of file kinetic_operation\&.c\&.
.PP
References KINETIC_ASSERT, KINETIC_STATUS_CONNECTION_ERROR, KineticOperation_SendRequestInLock(), KineticRequest_LockOperation(), and KineticRequest_UnlockOperation()\&.
.SS "static void log_request_seq_id (intfd, int64_tseq_id, \fBKineticMessageType\fPmt)\fC [static]\fP"

.PP
Definition at line 62 of file kinetic_operation\&.c\&.
.PP
References LOGF2\&.
.SS "\fBKineticStatus\fP KineticOperation_GetStatus (const KineticOperation *constoperation)"

.PP
Definition at line 143 of file kinetic_operation\&.c\&.
.PP
References KINETIC_STATUS_INVALID, and KineticResponse_GetStatus()\&.
.SS "void KineticOperation_Complete (KineticOperation *operation, \fBKineticStatus\fPstatus)"

.PP
Definition at line 162 of file kinetic_operation\&.c\&.
.PP
References KINETIC_ASSERT, KineticAllocator_FreeOperation(), KineticCountingSemaphore_Give(), and KineticCompletionData::status\&.
.SS "\fBKineticStatus\fP KineticOperation_NoopCallback (KineticOperation *constoperation, \fBKineticStatus\fP conststatus)"

.PP
Definition at line 184 of file kinetic_operation\&.c\&.
.PP
References KINETIC_ASSERT, and LOGF3\&.
.SS "void KineticOperation_BuildNoop (KineticOperation *constoperation)"

.PP
Definition at line 193 of file kinetic_operation\&.c\&.
.PP
References KINETIC_PROTO_COMMAND_MESSAGE_TYPE_NOOP, KineticOperation_NoopCallback(), and KineticOperation_ValidateOperation()\&.
.SS "\fBKineticStatus\fP KineticOperation_PutCallback (KineticOperation *constoperation, \fBKineticStatus\fP conststatus)"

.PP
Definition at line 201 of file kinetic_operation\&.c\&.
.PP
References ByteBuffer::array, BYTE_BUFFER_NONE, ByteBuffer_Append(), ByteBuffer_Reset(), ByteBuffer::bytesUsed, ByteArray::data, KineticEntry::dbVersion, KINETIC_ASSERT, KINETIC_STATUS_SUCCESS, ByteArray::len, LOGF3, and KineticEntry::newVersion\&.
.SS "\fBKineticStatus\fP KineticOperation_BuildPut (KineticOperation *constoperation, \fBKineticEntry\fP *constentry)"

.PP
Definition at line 233 of file kinetic_operation\&.c\&.
.PP
References ByteBuffer::bytesUsed, KINETIC_OBJ_SIZE, KINETIC_PROTO_COMMAND_MESSAGE_TYPE_PUT, KINETIC_STATUS_BUFFER_OVERRUN, KINETIC_STATUS_SUCCESS, KineticMessage_ConfigureKeyValue(), KineticOperation_PutCallback(), KineticOperation_ValidateOperation(), LOGF2, and KineticEntry::value\&.
.SS "static \fBKineticStatus\fP get_cb (const char *cmd_name, KineticOperation *constoperation, \fBKineticStatus\fP conststatus)\fC [static]\fP"

.PP
Definition at line 256 of file kinetic_operation\&.c\&.
.PP
References ByteBuffer_AppendArray(), ByteBuffer_IsNull(), Copy_KineticProto_Command_KeyValue_to_KineticEntry(), KINETIC_ASSERT, KINETIC_STATUS_BUFFER_OVERRUN, KINETIC_STATUS_SUCCESS, KineticResponse_GetKeyValue(), and LOGF3\&.
.SS "static void build_get_command (KineticOperation *constoperation, \fBKineticEntry\fP *constentry, \fBKineticOperationCallback\fPcb, \fBKineticProto_Command_MessageType\fPcommand_id)\fC [static]\fP"

.PP
Definition at line 288 of file kinetic_operation\&.c\&.
.PP
References ByteBuffer_Reset(), KineticMessage_ConfigureKeyValue(), and KineticOperation_ValidateOperation()\&.
.SS "static \fBKineticStatus\fP get_cmd_cb (KineticOperation *constoperation, \fBKineticStatus\fP conststatus)\fC [static]\fP"

.PP
Definition at line 310 of file kinetic_operation\&.c\&.
.PP
References get_cb()\&.
.SS "void KineticOperation_BuildGet (KineticOperation *constoperation, \fBKineticEntry\fP *constentry)"

.PP
Definition at line 315 of file kinetic_operation\&.c\&.
.PP
References build_get_command(), get_cmd_cb(), and KINETIC_PROTO_COMMAND_MESSAGE_TYPE_GET\&.
.SS "static \fBKineticStatus\fP getprevious_cmd_cb (KineticOperation *constoperation, \fBKineticStatus\fP conststatus)\fC [static]\fP"

.PP
Definition at line 322 of file kinetic_operation\&.c\&.
.PP
References get_cb()\&.
.SS "void KineticOperation_BuildGetPrevious (KineticOperation *constoperation, \fBKineticEntry\fP *constentry)"

.PP
Definition at line 327 of file kinetic_operation\&.c\&.
.PP
References build_get_command(), getprevious_cmd_cb(), and KINETIC_PROTO_COMMAND_MESSAGE_TYPE_GETPREVIOUS\&.
.SS "static \fBKineticStatus\fP getnext_cmd_cb (KineticOperation *constoperation, \fBKineticStatus\fP conststatus)\fC [static]\fP"

.PP
Definition at line 334 of file kinetic_operation\&.c\&.
.PP
References get_cb()\&.
.SS "void KineticOperation_BuildGetNext (KineticOperation *constoperation, \fBKineticEntry\fP *constentry)"

.PP
Definition at line 339 of file kinetic_operation\&.c\&.
.PP
References build_get_command(), getnext_cmd_cb(), and KINETIC_PROTO_COMMAND_MESSAGE_TYPE_GETNEXT\&.
.SS "\fBKineticStatus\fP KineticOperation_FlushCallback (KineticOperation *constoperation, \fBKineticStatus\fP conststatus)"

.PP
Definition at line 346 of file kinetic_operation\&.c\&.
.PP
References KINETIC_ASSERT, and LOGF3\&.
.SS "void KineticOperation_BuildFlush (KineticOperation *constoperation)"

.PP
Definition at line 356 of file kinetic_operation\&.c\&.
.PP
References KINETIC_PROTO_COMMAND_MESSAGE_TYPE_FLUSHALLDATA, KineticOperation_FlushCallback(), and KineticOperation_ValidateOperation()\&.
.SS "\fBKineticStatus\fP KineticOperation_DeleteCallback (KineticOperation *constoperation, \fBKineticStatus\fP conststatus)"

.PP
Definition at line 366 of file kinetic_operation\&.c\&.
.PP
References KINETIC_ASSERT, and LOGF3\&.
.SS "void KineticOperation_BuildDelete (KineticOperation *constoperation, \fBKineticEntry\fP *constentry)"

.PP
Definition at line 376 of file kinetic_operation\&.c\&.
.PP
References ByteBuffer_Reset(), KINETIC_PROTO_COMMAND_MESSAGE_TYPE_DELETE, KineticMessage_ConfigureKeyValue(), KineticOperation_DeleteCallback(), and KineticOperation_ValidateOperation()\&.
.SS "\fBKineticStatus\fP KineticOperation_GetKeyRangeCallback (KineticOperation *constoperation, \fBKineticStatus\fP conststatus)"

.PP
Definition at line 396 of file kinetic_operation\&.c\&.
.PP
References Copy_KineticProto_Command_Range_to_ByteBufferArray(), KINETIC_ASSERT, KINETIC_STATUS_BUFFER_OVERRUN, KINETIC_STATUS_SUCCESS, KineticResponse_GetKeyRange(), and LOGF3\&.
.SS "void KineticOperation_BuildGetKeyRange (KineticOperation *constoperation, \fBKineticKeyRange\fP *range, \fBByteBufferArray\fP *buffers)"

.PP
Definition at line 419 of file kinetic_operation\&.c\&.
.PP
References KINETIC_ASSERT, KINETIC_PROTO_COMMAND_MESSAGE_TYPE_GETKEYRANGE, KineticMessage_ConfigureKeyRange(), KineticOperation_GetKeyRangeCallback(), and KineticOperation_ValidateOperation()\&.
.SS "\fBKineticStatus\fP KineticOperation_GetLogCallback (KineticOperation *constoperation, \fBKineticStatus\fP conststatus)"

.PP
Definition at line 435 of file kinetic_operation\&.c\&.
.PP
References KINETIC_ASSERT, KINETIC_STATUS_OPERATION_FAILED, KINETIC_STATUS_SUCCESS, KineticLogInfo_Create(), and LOGF3\&.
.SS "void KineticOperation_BuildGetLog (KineticOperation *constoperation, \fBKineticLogInfo_Type\fPtype, \fBKineticLogInfo\fP **info)"

.PP
Definition at line 458 of file kinetic_operation\&.c\&.
.PP
References KINETIC_PROTO_COMMAND_MESSAGE_TYPE_GETLOG, KineticLogInfo_Type_to_KineticProto_Command_GetLog_Type(), KineticOperation_GetLogCallback(), and KineticOperation_ValidateOperation()\&.
.SS "void destroy_p2pOp (KineticProto_Command_P2POperation *proto_p2pOp)"

.PP
Definition at line 477 of file kinetic_operation\&.c\&.
.SS "KineticProto_Command_P2POperation* build_p2pOp (uint32_tnestingLevel, KineticP2P_Operation const *constp2pOp)"

.PP
Definition at line 506 of file kinetic_operation\&.c\&.
.PP
References ByteBuffer_IsNull(), destroy_p2pOp(), KINETIC_ASSERT, KINETIC_P2P_MAX_NESTING, KineticProto_command_p2_poperation__init(), KineticProto_command_p2_poperation_operation__init(), KineticProto_command_p2_poperation_peer__init(), and LOGF0\&.
.SS "static void populateP2PStatusCodes (KineticP2P_Operation *constp2pOp, KineticProto_Command_P2POperation const *constp2pOperation)\fC [static]\fP"

.PP
Definition at line 576 of file kinetic_operation\&.c\&.
.PP
References KINETIC_STATUS_INVALID, and KineticProtoStatusCode_to_KineticStatus()\&.
.SS "\fBKineticStatus\fP KineticOperation_P2POperationCallback (KineticOperation *constoperation, \fBKineticStatus\fP conststatus)"

.PP
Definition at line 605 of file kinetic_operation\&.c\&.
.PP
References destroy_p2pOp(), KINETIC_STATUS_SUCCESS, and populateP2PStatusCodes()\&.
.SS "\fBKineticStatus\fP KineticOperation_BuildP2POperation (KineticOperation *constoperation, KineticP2P_Operation *constp2pOp)"

.PP
Definition at line 624 of file kinetic_operation\&.c\&.
.PP
References build_p2pOp(), KINETIC_P2P_OPERATION_LIMIT, KINETIC_PROTO_COMMAND_MESSAGE_TYPE_PEER2PEERPUSH, KINETIC_STATUS_BUFFER_OVERRUN, KINETIC_STATUS_OPERATION_INVALID, KINETIC_STATUS_SUCCESS, KineticOperation_P2POperationCallback(), and KineticOperation_ValidateOperation()\&.
.SS "\fBKineticStatus\fP KineticOperation_SetPinCallback (KineticOperation *constoperation, \fBKineticStatus\fP conststatus)"

.PP
Definition at line 654 of file kinetic_operation\&.c\&.
.PP
References KINETIC_ASSERT, and LOGF3\&.
.SS "void KineticOperation_BuildSetPin (KineticOperation *constoperation, \fBByteArray\fPold_pin, \fBByteArray\fPnew_pin, boollock)"

.PP
Definition at line 663 of file kinetic_operation\&.c\&.
.PP
References ByteArray::data, KINETIC_PROTO_COMMAND_MESSAGE_TYPE_SECURITY, KineticOperation_SetPinCallback(), KineticOperation_TimeoutSetPin, KineticOperation_ValidateOperation(), and ByteArray::len\&.
.SS "\fBKineticStatus\fP KineticOperation_EraseCallback (KineticOperation *constoperation, \fBKineticStatus\fP conststatus)"

.PP
Definition at line 694 of file kinetic_operation\&.c\&.
.PP
References KINETIC_ASSERT, and LOGF3\&.
.SS "void KineticOperation_BuildErase (KineticOperation *constoperation, boolsecure_erase, \fBByteArray\fP *pin)"

.PP
Definition at line 703 of file kinetic_operation\&.c\&.
.PP
References KINETIC_PROTO_COMMAND_MESSAGE_TYPE_PINOP, KINETIC_PROTO_COMMAND_PIN_OPERATION_PIN_OP_TYPE_ERASE_PINOP, KINETIC_PROTO_COMMAND_PIN_OPERATION_PIN_OP_TYPE_SECURE_ERASE_PINOP, KineticOperation_EraseCallback(), KineticOperation_TimeoutErase, and KineticOperation_ValidateOperation()\&.
.SS "\fBKineticStatus\fP KineticOperation_LockUnlockCallback (KineticOperation *constoperation, \fBKineticStatus\fP conststatus)"

.PP
Definition at line 722 of file kinetic_operation\&.c\&.
.PP
References KINETIC_ASSERT, and LOGF3\&.
.SS "void KineticOperation_BuildLockUnlock (KineticOperation *constoperation, boollock, \fBByteArray\fP *pin)"

.PP
Definition at line 731 of file kinetic_operation\&.c\&.
.PP
References KINETIC_PROTO_COMMAND_MESSAGE_TYPE_PINOP, KINETIC_PROTO_COMMAND_PIN_OPERATION_PIN_OP_TYPE_LOCK_PINOP, KINETIC_PROTO_COMMAND_PIN_OPERATION_PIN_OP_TYPE_UNLOCK_PINOP, KineticOperation_LockUnlockCallback(), KineticOperation_TimeoutLockUnlock, and KineticOperation_ValidateOperation()\&.
.SS "\fBKineticStatus\fP KineticOperation_SetClusterVersionCallback (KineticOperation *constoperation, \fBKineticStatus\fP conststatus)"

.PP
Definition at line 751 of file kinetic_operation\&.c\&.
.PP
References KINETIC_ASSERT, KINETIC_STATUS_SUCCESS, KineticSession_SetClusterVersion(), and LOGF3\&.
.SS "void KineticOperation_BuildSetClusterVersion (KineticOperation *operation, int64_tnew_cluster_version)"

.PP
Definition at line 764 of file kinetic_operation\&.c\&.
.PP
References KINETIC_PROTO_COMMAND_MESSAGE_TYPE_SETUP, KineticOperation_SetClusterVersionCallback(), and KineticOperation_ValidateOperation()\&.
.SS "\fBKineticStatus\fP KineticOperation_SetACLCallback (KineticOperation *constoperation, \fBKineticStatus\fP conststatus)"

.PP
Definition at line 780 of file kinetic_operation\&.c\&.
.PP
References KINETIC_ASSERT, and LOGF3\&.
.SS "void KineticOperation_BuildSetACL (KineticOperation *constoperation, struct \fBACL\fP *ACLs)"

.PP
Definition at line 790 of file kinetic_operation\&.c\&.
.PP
References ACL::ACL_count, ACL::ACLs, KINETIC_PROTO_COMMAND_MESSAGE_TYPE_SECURITY, KineticOperation_SetACLCallback(), KineticOperation_TimeoutSetACL, and KineticOperation_ValidateOperation()\&.
.SS "\fBKineticStatus\fP KineticOperation_UpdateFirmwareCallback (KineticOperation *constoperation, \fBKineticStatus\fP conststatus)"

.PP
Definition at line 807 of file kinetic_operation\&.c\&.
.PP
References KINETIC_ASSERT, and LOGF3\&.
.SS "\fBKineticStatus\fP KineticOperation_BuildUpdateFirmware (KineticOperation *constoperation, const char *fw_path)"

.PP
Definition at line 822 of file kinetic_operation\&.c\&.
.PP
References KINETIC_PROTO_COMMAND_MESSAGE_TYPE_SETUP, KINETIC_STATUS_INVALID, KINETIC_STATUS_INVALID_FILE, KINETIC_STATUS_MEMORY_ERROR, KINETIC_STATUS_SUCCESS, KineticOperation_UpdateFirmwareCallback(), KineticOperation_ValidateOperation(), LOG0, and LOGF0\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for kinetic-c from the source code\&.
