.TH "kinetic_types.h" 3 "Tue Dec 9 2014" "Version v0.9.0" "kinetic-c" \" -*- nroff -*-
.ad l
.nh
.SH NAME
kinetic_types.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include <stdbool\&.h>\fP
.br
\fC#include <stdint\&.h>\fP
.br
\fC#include <inttypes\&.h>\fP
.br
\fC#include <stddef\&.h>\fP
.br
\fC#include <string\&.h>\fP
.br
\fC#include <stdio\&.h>\fP
.br
\fC#include <assert\&.h>\fP
.br
\fC#include <limits\&.h>\fP
.br
\fC#include <sys/time\&.h>\fP
.br
\fC#include 'byte_array\&.h'\fP
.br
\fC#include <unistd\&.h>\fP
.br
\fC#include <sys/types\&.h>\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBKineticSessionConfig\fP"
.br
.RI "\fIStructure used to specify the configuration for a session\&. \fP"
.ti -1c
.RI "struct \fBKineticSession\fP"
.br
.RI "\fIAn instance of a session with a Kinetic device\&. \fP"
.ti -1c
.RI "struct \fBKineticCompletionData\fP"
.br
.ti -1c
.RI "struct \fBKineticCompletionClosure\fP"
.br
.ti -1c
.RI "struct \fBKineticEntry\fP"
.br
.ti -1c
.RI "struct \fBKineticKeyRange\fP"
.br
.ti -1c
.RI "struct \fBKineticDeviceInfo_Utilization\fP"
.br
.ti -1c
.RI "struct \fBKineticDeviceInfo_Temperature\fP"
.br
.ti -1c
.RI "struct \fBKineticDeviceInfo_Capacity\fP"
.br
.ti -1c
.RI "struct \fBKineticDeviceInfo_Interface\fP"
.br
.ti -1c
.RI "struct \fBKineticDeviceInfo_Configuration\fP"
.br
.ti -1c
.RI "struct \fBKineticDeviceInfo_Statistics\fP"
.br
.ti -1c
.RI "struct \fBKineticDeviceInfo_Limits\fP"
.br
.ti -1c
.RI "struct \fBKineticDeviceInfo_Device\fP"
.br
.ti -1c
.RI "struct \fBKineticDeviceInfo\fP"
.br
.ti -1c
.RI "struct \fBKineticP2P_Peer\fP"
.br
.ti -1c
.RI "struct \fBKineticP2P_OperationData\fP"
.br
.ti -1c
.RI "struct \fBKineticP2P_Operation\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBKINETIC_HANDLE_INVALID\fP   (0)"
.br
.ti -1c
.RI "#define \fBKINETIC_PORT\fP   (8123)"
.br
.ti -1c
.RI "#define \fBKINETIC_TLS_PORT\fP   (8443)"
.br
.ti -1c
.RI "#define \fBKINETIC_HMAC_SHA1_LEN\fP   (SHA_DIGEST_LENGTH)"
.br
.ti -1c
.RI "#define \fBKINETIC_HMAC_MAX_LEN\fP   (\fBKINETIC_HMAC_SHA1_LEN\fP)"
.br
.ti -1c
.RI "#define \fBKINETIC_DEFAULT_KEY_LEN\fP   (1024)"
.br
.ti -1c
.RI "#define \fBKINETIC_MAX_KEY_LEN\fP   (4096)"
.br
.ti -1c
.RI "#define \fBKINETIC_MAX_VERSION_LEN\fP   (256)"
.br
.ti -1c
.RI "#define \fBKINETIC_OBJ_SIZE\fP   (1024 * 1024)"
.br
.ti -1c
.RI "#define \fB_BSD_SOURCE\fP"
.br
.ti -1c
.RI "#define \fBHOST_NAME_MAX\fP   256"
.br
.ti -1c
.RI "#define \fBLOG_FILE_NAME_MAX\fP   (\fBHOST_NAME_MAX\fP)"
.br
.ti -1c
.RI "#define \fBBOOL_TO_STRING\fP(_bool)   (_bool) ? 'true' : 'false'"
.br
.ti -1c
.RI "#define \fBKINETIC_SESSION_INIT\fP(_session, _host, _clusterVersion, _identity, _hmacKey)"
.br
.ti -1c
.RI "#define \fBKINETIC_DEVICE_INFO_SCRATCH_BUF_LEN\fP   (1024 * 1024 * 4)"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef void(* \fBKineticCompletionCallback\fP )(\fBKineticCompletionData\fP *kinetic_data, void *client_data)"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBKineticAlgorithm\fP "
.br
.RI "\fIEnumeration of encryption/checksum key algorithms\&. \fP"
.ti -1c
.RI "enum \fBKineticSynchronization\fP "
.br
.RI "\fIEnumeration of synchronization types for an operation\&. \fP"
.ti -1c
.RI "enum \fBKineticStatus\fP "
.br
.ti -1c
.RI "enum \fBKineticDeviceInfo_Type\fP "
.br
.ti -1c
.RI "enum \fBKineticMessageType\fP "
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "const char * \fBKinetic_GetStatusDescription\fP (\fBKineticStatus\fP status)"
.br
.ti -1c
.RI "const char * \fBKineticMessageType_GetName\fP (\fBKineticMessageType\fP type)"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define KINETIC_HANDLE_INVALID   (0)"

.PP
Definition at line 39 of file kinetic_types\&.h\&.
.SS "#define KINETIC_PORT   (8123)"

.PP
Definition at line 40 of file kinetic_types\&.h\&.
.SS "#define KINETIC_TLS_PORT   (8443)"

.PP
Definition at line 41 of file kinetic_types\&.h\&.
.SS "#define KINETIC_HMAC_SHA1_LEN   (SHA_DIGEST_LENGTH)"

.PP
Definition at line 42 of file kinetic_types\&.h\&.
.SS "#define KINETIC_HMAC_MAX_LEN   (\fBKINETIC_HMAC_SHA1_LEN\fP)"

.PP
Definition at line 43 of file kinetic_types\&.h\&.
.SS "#define KINETIC_DEFAULT_KEY_LEN   (1024)"

.PP
Definition at line 44 of file kinetic_types\&.h\&.
.SS "#define KINETIC_MAX_KEY_LEN   (4096)"

.PP
Definition at line 45 of file kinetic_types\&.h\&.
.SS "#define KINETIC_MAX_VERSION_LEN   (256)"

.PP
Definition at line 46 of file kinetic_types\&.h\&.
.SS "#define KINETIC_OBJ_SIZE   (1024 * 1024)"

.PP
Definition at line 47 of file kinetic_types\&.h\&.
.SS "#define _BSD_SOURCE"

.PP
Definition at line 52 of file kinetic_types\&.h\&.
.SS "#define HOST_NAME_MAX   256"

.PP
Definition at line 57 of file kinetic_types\&.h\&.
.SS "#define LOG_FILE_NAME_MAX   (\fBHOST_NAME_MAX\fP)"

.PP
Definition at line 61 of file kinetic_types\&.h\&.
.SS "#define BOOL_TO_STRING(_bool)   (_bool) ? 'true' : 'false'"

.PP
Definition at line 64 of file kinetic_types\&.h\&.
.SS "#define KINETIC_SESSION_INIT(_session, _host, _clusterVersion, _identity, _hmacKey)"
\fBValue:\fP
.PP
.nf
{ \
    (*_session)\&.config = (KineticSessionConfig) { \
        \&.port = KINETIC_PORT, \
        \&.clusterVersion = (_clusterVersion), \
        \&.identity = (_identity), \
        \&.hmacKey = {\&.data = (_session)->config\&.keyData, \&.len = (_hmacKey)\&.len}, \
    }; \
    strcpy((_session)->config\&.host, (_host)); \
    memcpy((_session)->config\&.hmacKey\&.data, (_hmacKey)\&.data, (_hmacKey)\&.len); \
}
.fi
.PP
Definition at line 134 of file kinetic_types\&.h\&.
.SS "#define KINETIC_DEVICE_INFO_SCRATCH_BUF_LEN   (1024 * 1024 * 4)"

.PP
Definition at line 357 of file kinetic_types\&.h\&.
.SH "Typedef Documentation"
.PP 
.SS "typedef void(* KineticCompletionCallback)(\fBKineticCompletionData\fP *kinetic_data, void *client_data)"

.PP
Definition at line 183 of file kinetic_types\&.h\&.
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBKineticAlgorithm\fP"

.PP
Enumeration of encryption/checksum key algorithms\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIKINETIC_ALGORITHM_INVALID \fP\fP
.TP
\fB\fIKINETIC_ALGORITHM_SHA1 \fP\fP
.TP
\fB\fIKINETIC_ALGORITHM_SHA2 \fP\fP
.TP
\fB\fIKINETIC_ALGORITHM_SHA3 \fP\fP
.TP
\fB\fIKINETIC_ALGORITHM_CRC32 \fP\fP
.TP
\fB\fIKINETIC_ALGORITHM_CRC64 \fP\fP
.PP
Definition at line 69 of file kinetic_types\&.h\&.
.SS "enum \fBKineticSynchronization\fP"

.PP
Enumeration of synchronization types for an operation\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIKINETIC_SYNCHRONIZATION_INVALID \fP\fP
.TP
\fB\fIKINETIC_SYNCHRONIZATION_WRITETHROUGH \fP\fP
.TP
\fB\fIKINETIC_SYNCHRONIZATION_WRITEBACK \fP\fP
.TP
\fB\fIKINETIC_SYNCHRONIZATION_FLUSH \fP\fP
.PP
Definition at line 82 of file kinetic_types\&.h\&.
.SS "enum \fBKineticStatus\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIKINETIC_STATUS_INVALID \fP\fP
.TP
\fB\fIKINETIC_STATUS_NOT_ATTEMPTED \fP\fP
.TP
\fB\fIKINETIC_STATUS_SUCCESS \fP\fP
.TP
\fB\fIKINETIC_STATUS_SESSION_EMPTY \fP\fP
.TP
\fB\fIKINETIC_STATUS_SESSION_INVALID \fP\fP
.TP
\fB\fIKINETIC_STATUS_HOST_EMPTY \fP\fP
.TP
\fB\fIKINETIC_STATUS_HMAC_EMPTY \fP\fP
.TP
\fB\fIKINETIC_STATUS_NO_PDUS_AVAVILABLE \fP\fP
.TP
\fB\fIKINETIC_STATUS_DEVICE_BUSY \fP\fP
.TP
\fB\fIKINETIC_STATUS_CONNECTION_ERROR \fP\fP
.TP
\fB\fIKINETIC_STATUS_INVALID_REQUEST \fP\fP
.TP
\fB\fIKINETIC_STATUS_OPERATION_INVALID \fP\fP
.TP
\fB\fIKINETIC_STATUS_OPERATION_FAILED \fP\fP
.TP
\fB\fIKINETIC_STATUS_OPERATION_TIMEDOUT \fP\fP
.TP
\fB\fIKINETIC_STATUS_CLUSTER_MISMATCH \fP\fP
.TP
\fB\fIKINETIC_STATUS_VERSION_MISMATCH \fP\fP
.TP
\fB\fIKINETIC_STATUS_DATA_ERROR \fP\fP
.TP
\fB\fIKINETIC_STATUS_NOT_FOUND \fP\fP
.TP
\fB\fIKINETIC_STATUS_BUFFER_OVERRUN \fP\fP
.TP
\fB\fIKINETIC_STATUS_MEMORY_ERROR \fP\fP
.TP
\fB\fIKINETIC_STATUS_SOCKET_TIMEOUT \fP\fP
.TP
\fB\fIKINETIC_STATUS_SOCKET_ERROR \fP\fP
.TP
\fB\fIKINETIC_STATUS_MISSING_KEY \fP\fP
.TP
\fB\fIKINETIC_STATUS_MISSING_VALUE_BUFFER \fP\fP
.TP
\fB\fIKINETIC_STATUS_COUNT \fP\fP
.PP
Definition at line 146 of file kinetic_types\&.h\&.
.SS "enum \fBKineticDeviceInfo_Type\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIKINETIC_DEVICE_INFO_TYPE_UTILIZATIONS \fP\fP
.TP
\fB\fIKINETIC_DEVICE_INFO_TYPE_TEMPERATURES \fP\fP
.TP
\fB\fIKINETIC_DEVICE_INFO_TYPE_CAPACITIES \fP\fP
.TP
\fB\fIKINETIC_DEVICE_INFO_TYPE_CONFIGURATION \fP\fP
.TP
\fB\fIKINETIC_DEVICE_INFO_TYPE_STATISTICS \fP\fP
.TP
\fB\fIKINETIC_DEVICE_INFO_TYPE_MESSAGES \fP\fP
.TP
\fB\fIKINETIC_DEVICE_INFO_TYPE_LIMITS \fP\fP
.TP
\fB\fIKINETIC_DEVICE_INFO_TYPE_DEVICE \fP\fP
.PP
Definition at line 218 of file kinetic_types\&.h\&.
.SS "enum \fBKineticMessageType\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIKINETIC_MESSAGE_TYPE_INVALID \fP\fP
.TP
\fB\fIKINETIC_MESSAGE_TYPE_GET_RESPONSE \fP\fP
.TP
\fB\fIKINETIC_MESSAGE_TYPE_GET \fP\fP
.TP
\fB\fIKINETIC_MESSAGE_TYPE_PUT_RESPONSE \fP\fP
.TP
\fB\fIKINETIC_MESSAGE_TYPE_PUT \fP\fP
.TP
\fB\fIKINETIC_MESSAGE_TYPE_DELETE_RESPONSE \fP\fP
.TP
\fB\fIKINETIC_MESSAGE_TYPE_DELETE \fP\fP
.TP
\fB\fIKINETIC_MESSAGE_TYPE_GETNEXT_RESPONSE \fP\fP
.TP
\fB\fIKINETIC_MESSAGE_TYPE_GETNEXT \fP\fP
.TP
\fB\fIKINETIC_MESSAGE_TYPE_GETPREVIOUS_RESPONSE \fP\fP
.TP
\fB\fIKINETIC_MESSAGE_TYPE_GETPREVIOUS \fP\fP
.TP
\fB\fIKINETIC_MESSAGE_TYPE_GETKEYRANGE_RESPONSE \fP\fP
.TP
\fB\fIKINETIC_MESSAGE_TYPE_GETKEYRANGE \fP\fP
.TP
\fB\fIKINETIC_MESSAGE_TYPE_GETVERSION_RESPONSE \fP\fP
.TP
\fB\fIKINETIC_MESSAGE_TYPE_GETVERSION \fP\fP
.TP
\fB\fIKINETIC_MESSAGE_TYPE_SETUP_RESPONSE \fP\fP
.TP
\fB\fIKINETIC_MESSAGE_TYPE_SETUP \fP\fP
.TP
\fB\fIKINETIC_MESSAGE_TYPE_GETLOG_RESPONSE \fP\fP
.TP
\fB\fIKINETIC_MESSAGE_TYPE_GETLOG \fP\fP
.TP
\fB\fIKINETIC_MESSAGE_TYPE_SECURITY_RESPONSE \fP\fP
.TP
\fB\fIKINETIC_MESSAGE_TYPE_SECURITY \fP\fP
.TP
\fB\fIKINETIC_MESSAGE_TYPE_PEER2PEERPUSH_RESPONSE \fP\fP
.TP
\fB\fIKINETIC_MESSAGE_TYPE_PEER2PEERPUSH \fP\fP
.TP
\fB\fIKINETIC_MESSAGE_TYPE_NOOP_RESPONSE \fP\fP
.TP
\fB\fIKINETIC_MESSAGE_TYPE_NOOP \fP\fP
.TP
\fB\fIKINETIC_MESSAGE_TYPE_FLUSHALLDATA_RESPONSE \fP\fP
.TP
\fB\fIKINETIC_MESSAGE_TYPE_FLUSHALLDATA \fP\fP
.TP
\fB\fIKINETIC_MESSAGE_TYPE_PINOP_RESPONSE \fP\fP
.TP
\fB\fIKINETIC_MESSAGE_TYPE_PINOP \fP\fP
.TP
\fB\fIKINETIC_MESSAGE_TYPE_MEDIASCAN_RESPONSE \fP\fP
.TP
\fB\fIKINETIC_MESSAGE_TYPE_MEDIASCAN \fP\fP
.TP
\fB\fIKINETIC_MESSAGE_TYPE_MEDIAOPTIMIZE_RESPONSE \fP\fP
.TP
\fB\fIKINETIC_MESSAGE_TYPE_MEDIAOPTIMIZE \fP\fP
.PP
Definition at line 265 of file kinetic_types\&.h\&.
.SH "Function Documentation"
.PP 
.SS "const char* Kinetic_GetStatusDescription (\fBKineticStatus\fPstatus)"

.PP
Definition at line 56 of file kinetic_types\&.c\&.
.PP
References KINETIC_STATUS_COUNT\&.
.SS "const char* KineticMessageType_GetName (\fBKineticMessageType\fPtype)"

.PP
Definition at line 101 of file kinetic_types\&.c\&.
.PP
References KINETIC_MESSAGE_TYPE_DELETE, KINETIC_MESSAGE_TYPE_DELETE_RESPONSE, KINETIC_MESSAGE_TYPE_FLUSHALLDATA, KINETIC_MESSAGE_TYPE_FLUSHALLDATA_RESPONSE, KINETIC_MESSAGE_TYPE_GET, KINETIC_MESSAGE_TYPE_GET_RESPONSE, KINETIC_MESSAGE_TYPE_GETKEYRANGE, KINETIC_MESSAGE_TYPE_GETKEYRANGE_RESPONSE, KINETIC_MESSAGE_TYPE_GETLOG, KINETIC_MESSAGE_TYPE_GETLOG_RESPONSE, KINETIC_MESSAGE_TYPE_GETNEXT, KINETIC_MESSAGE_TYPE_GETNEXT_RESPONSE, KINETIC_MESSAGE_TYPE_GETPREVIOUS, KINETIC_MESSAGE_TYPE_GETPREVIOUS_RESPONSE, KINETIC_MESSAGE_TYPE_GETVERSION, KINETIC_MESSAGE_TYPE_GETVERSION_RESPONSE, KINETIC_MESSAGE_TYPE_INVALID, KINETIC_MESSAGE_TYPE_MEDIAOPTIMIZE, KINETIC_MESSAGE_TYPE_MEDIAOPTIMIZE_RESPONSE, KINETIC_MESSAGE_TYPE_MEDIASCAN, KINETIC_MESSAGE_TYPE_MEDIASCAN_RESPONSE, KINETIC_MESSAGE_TYPE_NOOP, KINETIC_MESSAGE_TYPE_NOOP_RESPONSE, KINETIC_MESSAGE_TYPE_PEER2PEERPUSH, KINETIC_MESSAGE_TYPE_PEER2PEERPUSH_RESPONSE, KINETIC_MESSAGE_TYPE_PINOP, KINETIC_MESSAGE_TYPE_PINOP_RESPONSE, KINETIC_MESSAGE_TYPE_PUT, KINETIC_MESSAGE_TYPE_PUT_RESPONSE, KINETIC_MESSAGE_TYPE_SECURITY, KINETIC_MESSAGE_TYPE_SECURITY_RESPONSE, KINETIC_MESSAGE_TYPE_SETUP, and KINETIC_MESSAGE_TYPE_SETUP_RESPONSE\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for kinetic-c from the source code\&.
