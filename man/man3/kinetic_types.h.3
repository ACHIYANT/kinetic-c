.TH "kinetic_types.h" 3 "Fri Mar 13 2015" "Version v0.12.0" "kinetic-c" \" -*- nroff -*-
.ad l
.nh
.SH NAME
kinetic_types.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include <stdbool\&.h>\fP
.br
\fC#include <stdint\&.h>\fP
.br
\fC#include <inttypes\&.h>\fP
.br
\fC#include <stddef\&.h>\fP
.br
\fC#include <string\&.h>\fP
.br
\fC#include <stdio\&.h>\fP
.br
\fC#include <assert\&.h>\fP
.br
\fC#include <limits\&.h>\fP
.br
\fC#include <sys/time\&.h>\fP
.br
\fC#include 'byte_array\&.h'\fP
.br
\fC#include <unistd\&.h>\fP
.br
\fC#include <sys/types\&.h>\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBKineticVersionInfo\fP"
.br
.RI "\fIkinetic-c library version info (returned from \fBKineticClient_Version()\fP) \fP"
.ti -1c
.RI "struct \fBKineticSessionConfig\fP"
.br
.RI "\fIStructure used to specify the configuration for a session\&. \fP"
.ti -1c
.RI "struct \fBKineticCompletionData\fP"
.br
.RI "\fICompletion data which will be provided to \fBKineticCompletionClosure\fP for asynchronous operations\&. \fP"
.ti -1c
.RI "struct \fBKineticCompletionClosure\fP"
.br
.RI "\fIClosure which can be specified for operations which support asynchronous mode\&. \fP"
.ti -1c
.RI "struct \fBKineticEntry\fP"
.br
.RI "\fIKinetic object instance\&. \fP"
.ti -1c
.RI "struct \fBKineticKeyRange\fP"
.br
.RI "\fIKinetic Key Range request structure\&. \fP"
.ti -1c
.RI "struct \fBKineticLogInfo_Utilization\fP"
.br
.RI "\fILog info untilization entry\&. \fP"
.ti -1c
.RI "struct \fBKineticLogInfo_Temperature\fP"
.br
.RI "\fILog info temperature entry\&. \fP"
.ti -1c
.RI "struct \fBKineticLogInfo_Capacity\fP"
.br
.RI "\fILog info capacity entry\&. \fP"
.ti -1c
.RI "struct \fBKineticLogInfo_Interface\fP"
.br
.RI "\fILog info network interface entry\&. \fP"
.ti -1c
.RI "struct \fBKineticLogInfo_Configuration\fP"
.br
.RI "\fILog info device configuration\&. \fP"
.ti -1c
.RI "struct \fBKineticLogInfo_Statistics\fP"
.br
.RI "\fILog info statistics entry\&. \fP"
.ti -1c
.RI "struct \fBKineticLogInfo_Limits\fP"
.br
.RI "\fILog info device limits\&. \fP"
.ti -1c
.RI "struct \fBKineticLogInfo_Device\fP"
.br
.RI "\fILog info device name (used as a key for device-specific log data) \fP"
.ti -1c
.RI "struct \fBKineticLogInfo\fP"
.br
.RI "\fIBase log info structure which is allocated by client and passed to KineticAdminClient_GetLog\&. \fP"
.ti -1c
.RI "struct \fBKineticP2P_Peer\fP"
.br
.RI "\fIConfiguration of remote peer for a PEER2PEERPUSH operation\&. \fP"
.ti -1c
.RI "struct \fBKineticP2P_OperationData\fP"
.br
.RI "\fIPeer-to-peer operation data structure\&. \fP"
.ti -1c
.RI "struct \fBKineticP2P_Operation\fP"
.br
.RI "\fIPeer-to-peer opearation instance\&. \fP"
.ti -1c
.RI "struct \fBKineticClientConfig\fP"
.br
.RI "\fIConfiguration values for the KineticClient connection\&. \fP"
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBKINETIC_SOCKET_INVALID\fP   (-1)"
.br
.RI "\fIInvalid socket file descriptor value\&. \fP"
.ti -1c
.RI "#define \fBKINETIC_PORT\fP   (8123)"
.br
.RI "\fIDefault kinetic port\&. \fP"
.ti -1c
.RI "#define \fBKINETIC_TLS_PORT\fP   (8443)"
.br
.RI "\fIDefault kinetic TLS port\&. \fP"
.ti -1c
.RI "#define \fBKINETIC_HMAC_SHA1_LEN\fP   (SHA_DIGEST_LENGTH)"
.br
.RI "\fIHMAC secure hash length\&. \fP"
.ti -1c
.RI "#define \fBKINETIC_HMAC_MAX_LEN\fP   (\fBKINETIC_HMAC_SHA1_LEN\fP)"
.br
.RI "\fIHMAC max length\&. \fP"
.ti -1c
.RI "#define \fBKINETIC_PIN_MAX_LEN\fP   (1024)"
.br
.RI "\fIMax PIN length\&. \fP"
.ti -1c
.RI "#define \fBKINETIC_DEFAULT_KEY_LEN\fP   (1024)"
.br
.RI "\fIDefault key length\&. \fP"
.ti -1c
.RI "#define \fBKINETIC_MAX_KEY_LEN\fP   (4096)"
.br
.RI "\fIMax key length\&. \fP"
.ti -1c
.RI "#define \fBKINETIC_OBJ_SIZE\fP   (1024 * 1024)"
.br
.RI "\fIMax object/value size\&. \fP"
.ti -1c
.RI "#define \fB_BSD_SOURCE\fP"
.br
.ti -1c
.RI "#define \fBHOST_NAME_MAX\fP   256"
.br
.ti -1c
.RI "#define \fBKINETIC_P2P_OPERATION_LIMIT\fP   100000"
.br
.RI "\fILimit for P2P operations\&. \fP"
.ti -1c
.RI "#define \fBKINETIC_P2P_MAX_NESTING\fP   1000"
.br
.RI "\fILimit for P2P operation nesting\&. \fP"
.ti -1c
.RI "#define \fBKINETIC_CLIENT_DEFAULT_LOG_LEVEL\fP   0"
.br
.RI "\fIDefault values for the \fBKineticClientConfig\fP struct, which will be used if the corresponding field in the struct is 0\&. \fP"
.ti -1c
.RI "#define \fBKINETIC_CLIENT_DEFAULT_READER_THREADS\fP   4"
.br
.ti -1c
.RI "#define \fBKINETIC_CLIENT_DEFAULT_MAX_THREADPOOL_THREADS\fP   8"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef void(* \fBKineticCompletionCallback\fP )(\fBKineticCompletionData\fP *kinetic_data, void *client_data)"
.br
.RI "\fIOperation completion callback function prototype\&. \fP"
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBKineticAlgorithm\fP "
.br
.RI "\fIEnumeration of encryption/checksum key algorithms\&. \fP"
.ti -1c
.RI "enum \fBKineticSynchronization\fP "
.br
.RI "\fIEnumeration of synchronization types for an operation on a \fC\fBKineticEntry\fP\fP\&. \fP"
.ti -1c
.RI "enum \fBKineticStatus\fP "
.br
.RI "\fIKinetic status codes\&. \fP"
.ti -1c
.RI "enum \fBKineticLogInfo_Type\fP "
.br
.RI "\fILog info type\&. \fP"
.ti -1c
.RI "enum \fBKineticMessageType\fP "
.br
.RI "\fILog info message types\&. \fP"
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "const char * \fBKinetic_GetStatusDescription\fP (\fBKineticStatus\fP status)"
.br
.RI "\fIProvides a string representation for a KineticStatus code\&. \fP"
.ti -1c
.RI "const char * \fBKineticMessageType_GetName\fP (\fBKineticMessageType\fP type)"
.br
.RI "\fIProvides a string representation for a Kinetic message type\&. \fP"
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define KINETIC_SOCKET_INVALID   (-1)"

.PP
Invalid socket file descriptor value\&. 
.PP
Definition at line 39 of file kinetic_types\&.h\&.
.SS "#define KINETIC_PORT   (8123)"

.PP
Default kinetic port\&. 
.PP
Definition at line 40 of file kinetic_types\&.h\&.
.SS "#define KINETIC_TLS_PORT   (8443)"

.PP
Default kinetic TLS port\&. 
.PP
Definition at line 41 of file kinetic_types\&.h\&.
.SS "#define KINETIC_HMAC_SHA1_LEN   (SHA_DIGEST_LENGTH)"

.PP
HMAC secure hash length\&. 
.PP
Definition at line 42 of file kinetic_types\&.h\&.
.SS "#define KINETIC_HMAC_MAX_LEN   (\fBKINETIC_HMAC_SHA1_LEN\fP)"

.PP
HMAC max length\&. 
.PP
Definition at line 43 of file kinetic_types\&.h\&.
.SS "#define KINETIC_PIN_MAX_LEN   (1024)"

.PP
Max PIN length\&. 
.PP
Definition at line 44 of file kinetic_types\&.h\&.
.SS "#define KINETIC_DEFAULT_KEY_LEN   (1024)"

.PP
Default key length\&. 
.PP
Definition at line 45 of file kinetic_types\&.h\&.
.SS "#define KINETIC_MAX_KEY_LEN   (4096)"

.PP
Max key length\&. 
.PP
Definition at line 46 of file kinetic_types\&.h\&.
.SS "#define KINETIC_OBJ_SIZE   (1024 * 1024)"

.PP
Max object/value size\&. 
.PP
Definition at line 47 of file kinetic_types\&.h\&.
.SS "#define _BSD_SOURCE"

.PP
Definition at line 52 of file kinetic_types\&.h\&.
.SS "#define HOST_NAME_MAX   256"

.PP
Definition at line 57 of file kinetic_types\&.h\&.
.SS "#define KINETIC_P2P_OPERATION_LIMIT   100000"

.PP
Limit for P2P operations\&. 
.PP
Definition at line 479 of file kinetic_types\&.h\&.
.SS "#define KINETIC_P2P_MAX_NESTING   1000"

.PP
Limit for P2P operation nesting\&. 
.PP
Definition at line 484 of file kinetic_types\&.h\&.
.SS "#define KINETIC_CLIENT_DEFAULT_LOG_LEVEL   0"

.PP
Default values for the \fBKineticClientConfig\fP struct, which will be used if the corresponding field in the struct is 0\&. 
.PP
Definition at line 490 of file kinetic_types\&.h\&.
.SS "#define KINETIC_CLIENT_DEFAULT_READER_THREADS   4"

.PP
Definition at line 491 of file kinetic_types\&.h\&.
.SS "#define KINETIC_CLIENT_DEFAULT_MAX_THREADPOOL_THREADS   8"

.PP
Definition at line 492 of file kinetic_types\&.h\&.
.SH "Typedef Documentation"
.PP 
.SS "typedef void(* KineticCompletionCallback)(\fBKineticCompletionData\fP *kinetic_data, void *client_data)"

.PP
Operation completion callback function prototype\&. 
.PP
\fBParameters:\fP
.RS 4
\fIkinetic_data\fP \fBKineticCompletionData\fP provided by kinetic-c\&. 
.br
\fIclient_data\fP Optional pointer to arbitrary client-supplied data\&. 
.RE
.PP

.PP
Definition at line 219 of file kinetic_types\&.h\&.
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBKineticAlgorithm\fP"

.PP
Enumeration of encryption/checksum key algorithms\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIKINETIC_ALGORITHM_INVALID \fP\fP
Invalid algorithm value\&. 
.TP
\fB\fIKINETIC_ALGORITHM_SHA1 \fP\fP
SHA1\&. 
.TP
\fB\fIKINETIC_ALGORITHM_SHA2 \fP\fP
SHA2\&. 
.TP
\fB\fIKINETIC_ALGORITHM_SHA3 \fP\fP
SHA3\&. 
.TP
\fB\fIKINETIC_ALGORITHM_CRC32 \fP\fP
CRC32\&. 
.TP
\fB\fIKINETIC_ALGORITHM_CRC64 \fP\fP
CRC64\&. 
.PP
Definition at line 73 of file kinetic_types\&.h\&.
.SS "enum \fBKineticSynchronization\fP"

.PP
Enumeration of synchronization types for an operation on a \fC\fBKineticEntry\fP\fP\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIKINETIC_SYNCHRONIZATION_INVALID \fP\fP
Invalid synchronization value\&. 
.TP
\fB\fIKINETIC_SYNCHRONIZATION_WRITETHROUGH \fP\fP
This request is made persistent before returning\&. This does not effect any other pending operations\&. 
.TP
\fB\fIKINETIC_SYNCHRONIZATION_WRITEBACK \fP\fP
They can be made persistent when the drive chooses, or when a subsequent FLUSH is sent to the drive\&. 
.TP
\fB\fIKINETIC_SYNCHRONIZATION_FLUSH \fP\fP
All pending information that has not been written is pushed to the disk and the command that specifies FLUSH is written last and then returned\&. All WRITEBACK writes that have received ending status will be guaranteed to be written before the FLUSH operation is returned completed\&. 
.PP
Definition at line 86 of file kinetic_types\&.h\&.
.SS "enum \fBKineticStatus\fP"

.PP
Kinetic status codes\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIKINETIC_STATUS_INVALID \fP\fP
Status not available (no reponse/status available) 
.TP
\fB\fIKINETIC_STATUS_NOT_ATTEMPTED \fP\fP
No operation has been attempted\&. 
.TP
\fB\fIKINETIC_STATUS_SUCCESS \fP\fP
Operation successful\&. 
.TP
\fB\fIKINETIC_STATUS_SESSION_EMPTY \fP\fP
Session was NULL in request\&. 
.TP
\fB\fIKINETIC_STATUS_SESSION_INVALID \fP\fP
Session configuration was invalid or NULL\&. 
.TP
\fB\fIKINETIC_STATUS_HOST_EMPTY \fP\fP
Host was empty in request\&. 
.TP
\fB\fIKINETIC_STATUS_HMAC_REQUIRED \fP\fP
HMAC key is empty or NULL\&. 
.TP
\fB\fIKINETIC_STATUS_NO_PDUS_AVAVILABLE \fP\fP
All PDUs for the session have been allocated\&. 
.TP
\fB\fIKINETIC_STATUS_DEVICE_BUSY \fP\fP
Device busy (retry later) 
.TP
\fB\fIKINETIC_STATUS_CONNECTION_ERROR \fP\fP
No connection/disconnected\&. 
.TP
\fB\fIKINETIC_STATUS_INVALID_REQUEST \fP\fP
Something about the request is invalid\&. 
.TP
\fB\fIKINETIC_STATUS_OPERATION_INVALID \fP\fP
Operation was invalid\&. 
.TP
\fB\fIKINETIC_STATUS_OPERATION_FAILED \fP\fP
Device reported an operation error\&. 
.TP
\fB\fIKINETIC_STATUS_OPERATION_TIMEDOUT \fP\fP
Device did not respond to the operation in time\&. 
.TP
\fB\fIKINETIC_STATUS_CLUSTER_MISMATCH \fP\fP
Specified cluster version does not match device\&. 
.TP
\fB\fIKINETIC_STATUS_VERSION_MISMATCH \fP\fP
The specified object version info for a PUT/GET do not match stored object\&. 
.TP
\fB\fIKINETIC_STATUS_DATA_ERROR \fP\fP
Device reported data error, no space or HMAC failure\&. 
.TP
\fB\fIKINETIC_STATUS_NOT_FOUND \fP\fP
The requested object does not exist\&. 
.TP
\fB\fIKINETIC_STATUS_BUFFER_OVERRUN \fP\fP
One or more of byte buffers did not fit all data\&. 
.TP
\fB\fIKINETIC_STATUS_MEMORY_ERROR \fP\fP
Failed allocating/deallocating memory\&. 
.TP
\fB\fIKINETIC_STATUS_SOCKET_TIMEOUT \fP\fP
A timeout occurred while waiting for a socket operation\&. 
.TP
\fB\fIKINETIC_STATUS_SOCKET_ERROR \fP\fP
An I/O error occurred during a socket operation\&. 
.TP
\fB\fIKINETIC_STATUS_MISSING_KEY \fP\fP
An operation is missing a required key\&. 
.TP
\fB\fIKINETIC_STATUS_MISSING_VALUE_BUFFER \fP\fP
An operation is missing a required value buffer\&. 
.TP
\fB\fIKINETIC_STATUS_MISSING_PIN \fP\fP
An operation is missing a PIN\&. 
.TP
\fB\fIKINETIC_STATUS_SSL_REQUIRED \fP\fP
The operation requires an SSL connection and the specified connection is non-SSL\&. 
.TP
\fB\fIKINETIC_STATUS_DEVICE_LOCKED \fP\fP
The operation failed because the device is securely locked\&. An UNLOCK must be issued to unlock for use\&. 
.TP
\fB\fIKINETIC_STATUS_ACL_ERROR \fP\fP
A security operation failed due to bad \fBACL(s)\fP 
.TP
\fB\fIKINETIC_STATUS_NOT_AUTHORIZED \fP\fP
Authorization failure\&. 
.TP
\fB\fIKINETIC_STATUS_INVALID_FILE \fP\fP
Specified file does not exist or could not be read/writtten\&. 
.TP
\fB\fIKINETIC_STATUS_REQUEST_REJECTED \fP\fP
No request was attempted\&. 
.TP
\fB\fIKINETIC_STATUS_DEVICE_NAME_REQUIRED \fP\fP
A device name is required, but was empty\&. 
.TP
\fB\fIKINETIC_STATUS_INVALID_LOG_TYPE \fP\fP
The device log type specified was invalid\&. 
.TP
\fB\fIKINETIC_STATUS_HMAC_FAILURE \fP\fP
An HMAC validation error was detected\&. 
.TP
\fB\fIKINETIC_STATUS_SESSION_TERMINATED \fP\fP
The session has been terminated by the Kinetic device\&. 
.TP
\fB\fIKINETIC_STATUS_COUNT \fP\fP
Number of status codes in KineticStatusDescriptor\&. 
.PP
Definition at line 155 of file kinetic_types\&.h\&.
.SS "enum \fBKineticLogInfo_Type\fP"

.PP
Log info type\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIKINETIC_DEVICE_INFO_TYPE_UTILIZATIONS \fP\fP
.TP
\fB\fIKINETIC_DEVICE_INFO_TYPE_TEMPERATURES \fP\fP
.TP
\fB\fIKINETIC_DEVICE_INFO_TYPE_CAPACITIES \fP\fP
.TP
\fB\fIKINETIC_DEVICE_INFO_TYPE_CONFIGURATION \fP\fP
.TP
\fB\fIKINETIC_DEVICE_INFO_TYPE_STATISTICS \fP\fP
.TP
\fB\fIKINETIC_DEVICE_INFO_TYPE_MESSAGES \fP\fP
.TP
\fB\fIKINETIC_DEVICE_INFO_TYPE_LIMITS \fP\fP
.PP
Definition at line 289 of file kinetic_types\&.h\&.
.SS "enum \fBKineticMessageType\fP"

.PP
Log info message types\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIKINETIC_MESSAGE_TYPE_INVALID \fP\fP
.TP
\fB\fIKINETIC_MESSAGE_TYPE_GET_RESPONSE \fP\fP
GET_RESPONSE\&. 
.TP
\fB\fIKINETIC_MESSAGE_TYPE_GET \fP\fP
GET\&. 
.TP
\fB\fIKINETIC_MESSAGE_TYPE_PUT_RESPONSE \fP\fP
PUT_RESPONSE\&. 
.TP
\fB\fIKINETIC_MESSAGE_TYPE_PUT \fP\fP
PUT\&. 
.TP
\fB\fIKINETIC_MESSAGE_TYPE_DELETE_RESPONSE \fP\fP
DELETE_RESPONSE\&. 
.TP
\fB\fIKINETIC_MESSAGE_TYPE_DELETE \fP\fP
DELETE\&. 
.TP
\fB\fIKINETIC_MESSAGE_TYPE_GETNEXT_RESPONSE \fP\fP
GETNEXT_RESPONSE\&. 
.TP
\fB\fIKINETIC_MESSAGE_TYPE_GETNEXT \fP\fP
GETNEXT\&. 
.TP
\fB\fIKINETIC_MESSAGE_TYPE_GETPREVIOUS_RESPONSE \fP\fP
GETPREVIOUS_RESPONSE\&. 
.TP
\fB\fIKINETIC_MESSAGE_TYPE_GETPREVIOUS \fP\fP
GETPREVIOUS\&. 
.TP
\fB\fIKINETIC_MESSAGE_TYPE_GETKEYRANGE_RESPONSE \fP\fP
GETKEYRANGE_RESPONSE\&. 
.TP
\fB\fIKINETIC_MESSAGE_TYPE_GETKEYRANGE \fP\fP
GETKEYRANGE\&. 
.TP
\fB\fIKINETIC_MESSAGE_TYPE_GETVERSION_RESPONSE \fP\fP
GETVERSION_RESPONSE\&. 
.TP
\fB\fIKINETIC_MESSAGE_TYPE_GETVERSION \fP\fP
GETVERSION\&. 
.TP
\fB\fIKINETIC_MESSAGE_TYPE_SETUP_RESPONSE \fP\fP
SETUP_RESPONSE\&. 
.TP
\fB\fIKINETIC_MESSAGE_TYPE_SETUP \fP\fP
SETUP\&. 
.TP
\fB\fIKINETIC_MESSAGE_TYPE_GETLOG_RESPONSE \fP\fP
GETLOG_RESPONSE\&. 
.TP
\fB\fIKINETIC_MESSAGE_TYPE_GETLOG \fP\fP
GETLOG\&. 
.TP
\fB\fIKINETIC_MESSAGE_TYPE_SECURITY_RESPONSE \fP\fP
SECURITY_RESPONSE\&. 
.TP
\fB\fIKINETIC_MESSAGE_TYPE_SECURITY \fP\fP
SECURITY\&. 
.TP
\fB\fIKINETIC_MESSAGE_TYPE_PEER2PEERPUSH_RESPONSE \fP\fP
PEER2PEERPUSH_RESPONSE\&. 
.TP
\fB\fIKINETIC_MESSAGE_TYPE_PEER2PEERPUSH \fP\fP
PEER2PEERPUSH\&. 
.TP
\fB\fIKINETIC_MESSAGE_TYPE_NOOP_RESPONSE \fP\fP
NOOP_RESPONSE\&. 
.TP
\fB\fIKINETIC_MESSAGE_TYPE_NOOP \fP\fP
NOOP\&. 
.TP
\fB\fIKINETIC_MESSAGE_TYPE_FLUSHALLDATA_RESPONSE \fP\fP
FLUSHALLDATA_RESPONSE\&. 
.TP
\fB\fIKINETIC_MESSAGE_TYPE_FLUSHALLDATA \fP\fP
FLUSHALLDATA\&. 
.TP
\fB\fIKINETIC_MESSAGE_TYPE_PINOP_RESPONSE \fP\fP
PINOP_RESPONSE\&. 
.TP
\fB\fIKINETIC_MESSAGE_TYPE_PINOP \fP\fP
PINOP\&. 
.TP
\fB\fIKINETIC_MESSAGE_TYPE_MEDIASCAN_RESPONSE \fP\fP
MEDIASCAN_RESPONSE\&. 
.TP
\fB\fIKINETIC_MESSAGE_TYPE_MEDIASCAN \fP\fP
MEDIASCAN\&. 
.TP
\fB\fIKINETIC_MESSAGE_TYPE_MEDIAOPTIMIZE_RESPONSE \fP\fP
MEDIAOPTIMIZE_RESPONSE\&. 
.TP
\fB\fIKINETIC_MESSAGE_TYPE_MEDIAOPTIMIZE \fP\fP
MEDIAOPTIMIZE\&. 
.PP
Definition at line 359 of file kinetic_types\&.h\&.
.SH "Function Documentation"
.PP 
.SS "const char* Kinetic_GetStatusDescription (\fBKineticStatus\fPstatus)"

.PP
Provides a string representation for a KineticStatus code\&. 
.PP
\fBParameters:\fP
.RS 4
\fIstatus\fP The status enumeration value\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Pointer to the appropriate string representation for the specified status\&. 
.RE
.PP

.PP
Definition at line 67 of file kinetic_types\&.c\&.
.PP
References KINETIC_STATUS_COUNT, KineticStatusDescriptor, and KineticStatusInvalid\&.
.SS "const char* KineticMessageType_GetName (\fBKineticMessageType\fPtype)"

.PP
Provides a string representation for a Kinetic message type\&. 
.PP
\fBParameters:\fP
.RS 4
\fItype\fP The message type value\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Pointer to the appropriate string representation for the specified type\&. 
.RE
.PP

.PP
Definition at line 112 of file kinetic_types\&.c\&.
.PP
References KINETIC_MESSAGE_TYPE_DELETE, KINETIC_MESSAGE_TYPE_DELETE_RESPONSE, KINETIC_MESSAGE_TYPE_FLUSHALLDATA, KINETIC_MESSAGE_TYPE_FLUSHALLDATA_RESPONSE, KINETIC_MESSAGE_TYPE_GET, KINETIC_MESSAGE_TYPE_GET_RESPONSE, KINETIC_MESSAGE_TYPE_GETKEYRANGE, KINETIC_MESSAGE_TYPE_GETKEYRANGE_RESPONSE, KINETIC_MESSAGE_TYPE_GETLOG, KINETIC_MESSAGE_TYPE_GETLOG_RESPONSE, KINETIC_MESSAGE_TYPE_GETNEXT, KINETIC_MESSAGE_TYPE_GETNEXT_RESPONSE, KINETIC_MESSAGE_TYPE_GETPREVIOUS, KINETIC_MESSAGE_TYPE_GETPREVIOUS_RESPONSE, KINETIC_MESSAGE_TYPE_GETVERSION, KINETIC_MESSAGE_TYPE_GETVERSION_RESPONSE, KINETIC_MESSAGE_TYPE_INVALID, KINETIC_MESSAGE_TYPE_MEDIAOPTIMIZE, KINETIC_MESSAGE_TYPE_MEDIAOPTIMIZE_RESPONSE, KINETIC_MESSAGE_TYPE_MEDIASCAN, KINETIC_MESSAGE_TYPE_MEDIASCAN_RESPONSE, KINETIC_MESSAGE_TYPE_NOOP, KINETIC_MESSAGE_TYPE_NOOP_RESPONSE, KINETIC_MESSAGE_TYPE_PEER2PEERPUSH, KINETIC_MESSAGE_TYPE_PEER2PEERPUSH_RESPONSE, KINETIC_MESSAGE_TYPE_PINOP, KINETIC_MESSAGE_TYPE_PINOP_RESPONSE, KINETIC_MESSAGE_TYPE_PUT, KINETIC_MESSAGE_TYPE_PUT_RESPONSE, KINETIC_MESSAGE_TYPE_SECURITY, KINETIC_MESSAGE_TYPE_SECURITY_RESPONSE, KINETIC_MESSAGE_TYPE_SETUP, and KINETIC_MESSAGE_TYPE_SETUP_RESPONSE\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for kinetic-c from the source code\&.
