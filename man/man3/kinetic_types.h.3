.TH "kinetic_types.h" 3 "Mon Mar 2 2015" "Version v0.12.0-beta" "kinetic-c" \" -*- nroff -*-
.ad l
.nh
.SH NAME
kinetic_types.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include <stdbool\&.h>\fP
.br
\fC#include <stdint\&.h>\fP
.br
\fC#include <inttypes\&.h>\fP
.br
\fC#include <stddef\&.h>\fP
.br
\fC#include <string\&.h>\fP
.br
\fC#include <stdio\&.h>\fP
.br
\fC#include <assert\&.h>\fP
.br
\fC#include <limits\&.h>\fP
.br
\fC#include <sys/time\&.h>\fP
.br
\fC#include 'byte_array\&.h'\fP
.br
\fC#include <unistd\&.h>\fP
.br
\fC#include <sys/types\&.h>\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBKineticSessionConfig\fP"
.br
.RI "\fIStructure used to specify the configuration for a session\&. \fP"
.ti -1c
.RI "struct \fBKineticCompletionData\fP"
.br
.RI "\fICompletion data which will be provided to \fBKineticCompletionClosure\fP for asynchronous operations\&. \fP"
.ti -1c
.RI "struct \fBKineticCompletionClosure\fP"
.br
.RI "\fIClosure which can be specified for operations which support asynchronous mode\&. \fP"
.ti -1c
.RI "struct \fBKineticEntry\fP"
.br
.RI "\fIKinetic object instance\&. \fP"
.ti -1c
.RI "struct \fBKineticKeyRange\fP"
.br
.RI "\fIKinetic Key Range request structure\&. \fP"
.ti -1c
.RI "struct \fBKineticLogInfo_Utilization\fP"
.br
.ti -1c
.RI "struct \fBKineticLogInfo_Temperature\fP"
.br
.ti -1c
.RI "struct \fBKineticLogInfo_Capacity\fP"
.br
.ti -1c
.RI "struct \fBKineticLogInfo_Interface\fP"
.br
.ti -1c
.RI "struct \fBKineticLogInfo_Configuration\fP"
.br
.ti -1c
.RI "struct \fBKineticLogInfo_Statistics\fP"
.br
.ti -1c
.RI "struct \fBKineticLogInfo_Limits\fP"
.br
.ti -1c
.RI "struct \fBKineticLogInfo_Device\fP"
.br
.ti -1c
.RI "struct \fBKineticLogInfo\fP"
.br
.ti -1c
.RI "struct \fBKineticP2P_Peer\fP"
.br
.RI "\fIConfiguration of remote peer for a PEER2PEERPUSH operation\&. \fP"
.ti -1c
.RI "struct \fBKineticP2P_OperationData\fP"
.br
.ti -1c
.RI "struct \fBKineticP2P_Operation\fP"
.br
.ti -1c
.RI "struct \fBKineticClientConfig\fP"
.br
.RI "\fIConfiguration values for the KineticClient connection\&. \fP"
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBKINETIC_HANDLE_INVALID\fP   (0)"
.br
.ti -1c
.RI "#define \fBKINETIC_PORT\fP   (8123)"
.br
.ti -1c
.RI "#define \fBKINETIC_TLS_PORT\fP   (8443)"
.br
.ti -1c
.RI "#define \fBKINETIC_HMAC_SHA1_LEN\fP   (SHA_DIGEST_LENGTH)"
.br
.ti -1c
.RI "#define \fBKINETIC_HMAC_MAX_LEN\fP   (\fBKINETIC_HMAC_SHA1_LEN\fP)"
.br
.ti -1c
.RI "#define \fBKINETIC_PIN_MAX_LEN\fP   (1024)"
.br
.ti -1c
.RI "#define \fBKINETIC_DEFAULT_KEY_LEN\fP   (1024)"
.br
.ti -1c
.RI "#define \fBKINETIC_MAX_KEY_LEN\fP   (4096)"
.br
.ti -1c
.RI "#define \fBKINETIC_MAX_VERSION_LEN\fP   (256)"
.br
.ti -1c
.RI "#define \fBKINETIC_OBJ_SIZE\fP   (1024 * 1024)"
.br
.ti -1c
.RI "#define \fB_BSD_SOURCE\fP"
.br
.ti -1c
.RI "#define \fBHOST_NAME_MAX\fP   256"
.br
.ti -1c
.RI "#define \fBLOG_FILE_NAME_MAX\fP   (\fBHOST_NAME_MAX\fP)"
.br
.ti -1c
.RI "#define \fBBOOL_TO_STRING\fP(_bool)   (_bool) ? 'true' : 'false'"
.br
.ti -1c
.RI "#define \fBKINETIC_SESSION_INIT\fP(_session, _host, _clusterVersion, _identity, _hmacKey)"
.br
.ti -1c
.RI "#define \fBKINETIC_P2P_OPERATION_LIMIT\fP   100000"
.br
.RI "\fILimit for P2P operations\&. \fP"
.ti -1c
.RI "#define \fBKINETIC_P2P_MAX_NESTING\fP   1000"
.br
.RI "\fILimit for P2P operation nesting\&. \fP"
.ti -1c
.RI "#define \fBKINETIC_CLIENT_DEFAULT_LOG_LEVEL\fP   0"
.br
.RI "\fIDefault values for the \fBKineticClientConfig\fP struct, which will be used if the corresponding field in the struct is 0\&. \fP"
.ti -1c
.RI "#define \fBKINETIC_CLIENT_DEFAULT_WRITER_THREADS\fP   4"
.br
.ti -1c
.RI "#define \fBKINETIC_CLIENT_DEFAULT_READER_THREADS\fP   4"
.br
.ti -1c
.RI "#define \fBKINETIC_CLIENT_DEFAULT_MAX_THREADPOOL_THREADS\fP   8"
.br
.ti -1c
.RI "#define \fBKINETIC_DEVICE_INFO_SCRATCH_BUF_LEN\fP   (1024 * 1024 * 4)"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef void(* \fBKineticCompletionCallback\fP )(\fBKineticCompletionData\fP *kinetic_data, void *client_data)"
.br
.RI "\fIOperation completion callback function prototype\&. \fP"
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBKineticAlgorithm\fP "
.br
.RI "\fIEnumeration of encryption/checksum key algorithms\&. \fP"
.ti -1c
.RI "enum \fBKineticSynchronization\fP "
.br
.RI "\fIEnumeration of synchronization types for an operation on a \fC\fBKineticEntry\fP\fP\&. \fP"
.ti -1c
.RI "enum \fBKineticStatus\fP "
.br
.RI "\fIKinetic status codes\&. \fP"
.ti -1c
.RI "enum \fBKineticLogInfo_Type\fP "
.br
.ti -1c
.RI "enum \fBKineticMessageType\fP "
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "const char * \fBKinetic_GetStatusDescription\fP (\fBKineticStatus\fP status)"
.br
.RI "\fIProvides a string representation for a KineticStatus code\&. \fP"
.ti -1c
.RI "const char * \fBKineticMessageType_GetName\fP (\fBKineticMessageType\fP type)"
.br
.RI "\fIProvides a string representation for a Kinetic message type\&. \fP"
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define KINETIC_HANDLE_INVALID   (0)"

.PP
Definition at line 39 of file kinetic_types\&.h\&.
.SS "#define KINETIC_PORT   (8123)"

.PP
Definition at line 40 of file kinetic_types\&.h\&.
.SS "#define KINETIC_TLS_PORT   (8443)"

.PP
Definition at line 41 of file kinetic_types\&.h\&.
.SS "#define KINETIC_HMAC_SHA1_LEN   (SHA_DIGEST_LENGTH)"

.PP
Definition at line 42 of file kinetic_types\&.h\&.
.SS "#define KINETIC_HMAC_MAX_LEN   (\fBKINETIC_HMAC_SHA1_LEN\fP)"

.PP
Definition at line 43 of file kinetic_types\&.h\&.
.SS "#define KINETIC_PIN_MAX_LEN   (1024)"

.PP
Definition at line 44 of file kinetic_types\&.h\&.
.SS "#define KINETIC_DEFAULT_KEY_LEN   (1024)"

.PP
Definition at line 45 of file kinetic_types\&.h\&.
.SS "#define KINETIC_MAX_KEY_LEN   (4096)"

.PP
Definition at line 46 of file kinetic_types\&.h\&.
.SS "#define KINETIC_MAX_VERSION_LEN   (256)"

.PP
Definition at line 47 of file kinetic_types\&.h\&.
.SS "#define KINETIC_OBJ_SIZE   (1024 * 1024)"

.PP
Definition at line 48 of file kinetic_types\&.h\&.
.SS "#define _BSD_SOURCE"

.PP
Definition at line 53 of file kinetic_types\&.h\&.
.SS "#define HOST_NAME_MAX   256"

.PP
Definition at line 58 of file kinetic_types\&.h\&.
.SS "#define LOG_FILE_NAME_MAX   (\fBHOST_NAME_MAX\fP)"

.PP
Definition at line 62 of file kinetic_types\&.h\&.
.SS "#define BOOL_TO_STRING(_bool)   (_bool) ? 'true' : 'false'"

.PP
Definition at line 65 of file kinetic_types\&.h\&.
.SS "#define KINETIC_SESSION_INIT(_session, _host, _clusterVersion, _identity, _hmacKey)"
\fBValue:\fP
.PP
.nf
{ \
    (*_session)\&.config = (KineticSessionConfig) { \
        \&.port = KINETIC_PORT, \
        \&.clusterVersion = (_clusterVersion), \
        \&.identity = (_identity), \
        \&.hmacKey = {\&.data = (_session)->config\&.keyData, \&.len = (_hmacKey)\&.len}, \
    }; \
    strcpy((_session)->config\&.host, (_host)); \
    memcpy((_session)->config\&.hmacKey\&.data, (_hmacKey)\&.data, (_hmacKey)\&.len); \
}
.fi
.PP
Definition at line 152 of file kinetic_types\&.h\&.
.SS "#define KINETIC_P2P_OPERATION_LIMIT   100000"

.PP
Limit for P2P operations\&. 
.PP
Definition at line 436 of file kinetic_types\&.h\&.
.SS "#define KINETIC_P2P_MAX_NESTING   1000"

.PP
Limit for P2P operation nesting\&. 
.PP
Definition at line 441 of file kinetic_types\&.h\&.
.SS "#define KINETIC_CLIENT_DEFAULT_LOG_LEVEL   0"

.PP
Default values for the \fBKineticClientConfig\fP struct, which will be used if the corresponding field in the struct is 0\&. 
.PP
Definition at line 447 of file kinetic_types\&.h\&.
.SS "#define KINETIC_CLIENT_DEFAULT_WRITER_THREADS   4"

.PP
Definition at line 448 of file kinetic_types\&.h\&.
.SS "#define KINETIC_CLIENT_DEFAULT_READER_THREADS   4"

.PP
Definition at line 449 of file kinetic_types\&.h\&.
.SS "#define KINETIC_CLIENT_DEFAULT_MAX_THREADPOOL_THREADS   8"

.PP
Definition at line 450 of file kinetic_types\&.h\&.
.SS "#define KINETIC_DEVICE_INFO_SCRATCH_BUF_LEN   (1024 * 1024 * 4)"

.PP
Definition at line 475 of file kinetic_types\&.h\&.
.SH "Typedef Documentation"
.PP 
.SS "typedef void(* KineticCompletionCallback)(\fBKineticCompletionData\fP *kinetic_data, void *client_data)"

.PP
Operation completion callback function prototype\&. 
.PP
\fBParameters:\fP
.RS 4
\fIkinetic_data\fP \fBKineticCompletionData\fP provided by kinetic-c\&. 
.br
\fIclient_data\fP Optional pointer to arbitrary client-supplied data\&. 
.RE
.PP

.PP
Definition at line 225 of file kinetic_types\&.h\&.
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBKineticAlgorithm\fP"

.PP
Enumeration of encryption/checksum key algorithms\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIKINETIC_ALGORITHM_INVALID \fP\fP
.TP
\fB\fIKINETIC_ALGORITHM_SHA1 \fP\fP
SHA1\&. 
.TP
\fB\fIKINETIC_ALGORITHM_SHA2 \fP\fP
SHA2\&. 
.TP
\fB\fIKINETIC_ALGORITHM_SHA3 \fP\fP
SHA3\&. 
.TP
\fB\fIKINETIC_ALGORITHM_CRC32 \fP\fP
CRC32\&. 
.TP
\fB\fIKINETIC_ALGORITHM_CRC64 \fP\fP
CRC64\&. 
.PP
Definition at line 70 of file kinetic_types\&.h\&.
.SS "enum \fBKineticSynchronization\fP"

.PP
Enumeration of synchronization types for an operation on a \fC\fBKineticEntry\fP\fP\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIKINETIC_SYNCHRONIZATION_INVALID \fP\fP
.TP
\fB\fIKINETIC_SYNCHRONIZATION_WRITETHROUGH \fP\fP
This request is made persistent before returning\&. This does not effect any other pending operations\&. 
.TP
\fB\fIKINETIC_SYNCHRONIZATION_WRITEBACK \fP\fP
They can be made persistent when the drive chooses, or when a subsequent FLUSH is sent to the drive\&. 
.TP
\fB\fIKINETIC_SYNCHRONIZATION_FLUSH \fP\fP
All pending information that has not been written is pushed to the disk and the command that specifies FLUSH is written last and then returned\&. All WRITEBACK writes that have received ending status will be guaranteed to be written before the FLUSH operation is returned completed\&. 
.PP
Definition at line 83 of file kinetic_types\&.h\&.
.SS "enum \fBKineticStatus\fP"

.PP
Kinetic status codes\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIKINETIC_STATUS_INVALID \fP\fP
Status not available (no reponse/status available) 
.TP
\fB\fIKINETIC_STATUS_NOT_ATTEMPTED \fP\fP
No operation has been attempted\&. 
.TP
\fB\fIKINETIC_STATUS_SUCCESS \fP\fP
Operation successful\&. 
.TP
\fB\fIKINETIC_STATUS_SESSION_EMPTY \fP\fP
Session was NULL in request\&. 
.TP
\fB\fIKINETIC_STATUS_SESSION_INVALID \fP\fP
Session configuration was invalid or NULL\&. 
.TP
\fB\fIKINETIC_STATUS_HOST_EMPTY \fP\fP
Host was empty in request\&. 
.TP
\fB\fIKINETIC_STATUS_HMAC_REQUIRED \fP\fP
HMAC key is empty or NULL\&. 
.TP
\fB\fIKINETIC_STATUS_NO_PDUS_AVAVILABLE \fP\fP
All PDUs for the session have been allocated\&. 
.TP
\fB\fIKINETIC_STATUS_DEVICE_BUSY \fP\fP
Device busy (retry later) 
.TP
\fB\fIKINETIC_STATUS_CONNECTION_ERROR \fP\fP
No connection/disconnected\&. 
.TP
\fB\fIKINETIC_STATUS_INVALID_REQUEST \fP\fP
Something about the request is invalid\&. 
.TP
\fB\fIKINETIC_STATUS_OPERATION_INVALID \fP\fP
Operation was invalid\&. 
.TP
\fB\fIKINETIC_STATUS_OPERATION_FAILED \fP\fP
Device reported an operation error\&. 
.TP
\fB\fIKINETIC_STATUS_OPERATION_TIMEDOUT \fP\fP
Device did not respond to the operation in time\&. 
.TP
\fB\fIKINETIC_STATUS_CLUSTER_MISMATCH \fP\fP
Specified cluster version does not match device\&. 
.TP
\fB\fIKINETIC_STATUS_VERSION_MISMATCH \fP\fP
The specified object version info for a PUT/GET do not match stored object\&. 
.TP
\fB\fIKINETIC_STATUS_DATA_ERROR \fP\fP
Device reported data error, no space or HMAC failure\&. 
.TP
\fB\fIKINETIC_STATUS_NOT_FOUND \fP\fP
The requested object does not exist\&. 
.TP
\fB\fIKINETIC_STATUS_BUFFER_OVERRUN \fP\fP
One or more of byte buffers did not fit all data\&. 
.TP
\fB\fIKINETIC_STATUS_MEMORY_ERROR \fP\fP
Failed allocating/deallocating memory\&. 
.TP
\fB\fIKINETIC_STATUS_SOCKET_TIMEOUT \fP\fP
A timeout occurred while waiting for a socket operation\&. 
.TP
\fB\fIKINETIC_STATUS_SOCKET_ERROR \fP\fP
An I/O error occurred during a socket operation\&. 
.TP
\fB\fIKINETIC_STATUS_MISSING_KEY \fP\fP
An operation is missing a required key\&. 
.TP
\fB\fIKINETIC_STATUS_MISSING_VALUE_BUFFER \fP\fP
An operation is missing a required value buffer\&. 
.TP
\fB\fIKINETIC_STATUS_MISSING_PIN \fP\fP
An operation is missing a PIN\&. 
.TP
\fB\fIKINETIC_STATUS_SSL_REQUIRED \fP\fP
The operation requires an SSL connection and the specified connection is non-SSL\&. 
.TP
\fB\fIKINETIC_STATUS_DEVICE_LOCKED \fP\fP
The operation failed because the device is securely locked\&. An UNLOCK must be issued to unlock for use\&. 
.TP
\fB\fIKINETIC_STATUS_ACL_ERROR \fP\fP
A security operation failed due to bad \fBACL(s)\fP 
.TP
\fB\fIKINETIC_STATUS_NOT_AUTHORIZED \fP\fP
Authorization failure\&. 
.TP
\fB\fIKINETIC_STATUS_INVALID_FILE \fP\fP
Specified file does not exist or could not be read/writtten\&. 
.TP
\fB\fIKINETIC_STATUS_COUNT \fP\fP
Number of status codes in KineticStatusDescriptor\&. 
.PP
Definition at line 166 of file kinetic_types\&.h\&.
.SS "enum \fBKineticLogInfo_Type\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIKINETIC_DEVICE_INFO_TYPE_UTILIZATIONS \fP\fP
.TP
\fB\fIKINETIC_DEVICE_INFO_TYPE_TEMPERATURES \fP\fP
.TP
\fB\fIKINETIC_DEVICE_INFO_TYPE_CAPACITIES \fP\fP
.TP
\fB\fIKINETIC_DEVICE_INFO_TYPE_CONFIGURATION \fP\fP
.TP
\fB\fIKINETIC_DEVICE_INFO_TYPE_STATISTICS \fP\fP
.TP
\fB\fIKINETIC_DEVICE_INFO_TYPE_MESSAGES \fP\fP
.TP
\fB\fIKINETIC_DEVICE_INFO_TYPE_LIMITS \fP\fP
.TP
\fB\fIKINETIC_DEVICE_INFO_TYPE_DEVICE \fP\fP
.PP
Definition at line 291 of file kinetic_types\&.h\&.
.SS "enum \fBKineticMessageType\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIKINETIC_MESSAGE_TYPE_INVALID \fP\fP
.TP
\fB\fIKINETIC_MESSAGE_TYPE_GET_RESPONSE \fP\fP
GET_RESPONSE\&. 
.TP
\fB\fIKINETIC_MESSAGE_TYPE_GET \fP\fP
GET\&. 
.TP
\fB\fIKINETIC_MESSAGE_TYPE_PUT_RESPONSE \fP\fP
PUT_RESPONSE\&. 
.TP
\fB\fIKINETIC_MESSAGE_TYPE_PUT \fP\fP
PUT\&. 
.TP
\fB\fIKINETIC_MESSAGE_TYPE_DELETE_RESPONSE \fP\fP
DELETE_RESPONSE\&. 
.TP
\fB\fIKINETIC_MESSAGE_TYPE_DELETE \fP\fP
DELETE\&. 
.TP
\fB\fIKINETIC_MESSAGE_TYPE_GETNEXT_RESPONSE \fP\fP
GETNEXT_RESPONSE\&. 
.TP
\fB\fIKINETIC_MESSAGE_TYPE_GETNEXT \fP\fP
GETNEXT\&. 
.TP
\fB\fIKINETIC_MESSAGE_TYPE_GETPREVIOUS_RESPONSE \fP\fP
GETPREVIOUS_RESPONSE\&. 
.TP
\fB\fIKINETIC_MESSAGE_TYPE_GETPREVIOUS \fP\fP
GETPREVIOUS\&. 
.TP
\fB\fIKINETIC_MESSAGE_TYPE_GETKEYRANGE_RESPONSE \fP\fP
GETKEYRANGE_RESPONSE\&. 
.TP
\fB\fIKINETIC_MESSAGE_TYPE_GETKEYRANGE \fP\fP
GETKEYRANGE\&. 
.TP
\fB\fIKINETIC_MESSAGE_TYPE_GETVERSION_RESPONSE \fP\fP
GETVERSION_RESPONSE\&. 
.TP
\fB\fIKINETIC_MESSAGE_TYPE_GETVERSION \fP\fP
GETVERSION\&. 
.TP
\fB\fIKINETIC_MESSAGE_TYPE_SETUP_RESPONSE \fP\fP
SETUP_RESPONSE\&. 
.TP
\fB\fIKINETIC_MESSAGE_TYPE_SETUP \fP\fP
SETUP\&. 
.TP
\fB\fIKINETIC_MESSAGE_TYPE_GETLOG_RESPONSE \fP\fP
GETLOG_RESPONSE\&. 
.TP
\fB\fIKINETIC_MESSAGE_TYPE_GETLOG \fP\fP
GETLOG\&. 
.TP
\fB\fIKINETIC_MESSAGE_TYPE_SECURITY_RESPONSE \fP\fP
SECURITY_RESPONSE\&. 
.TP
\fB\fIKINETIC_MESSAGE_TYPE_SECURITY \fP\fP
SECURITY\&. 
.TP
\fB\fIKINETIC_MESSAGE_TYPE_PEER2PEERPUSH_RESPONSE \fP\fP
PEER2PEERPUSH_RESPONSE\&. 
.TP
\fB\fIKINETIC_MESSAGE_TYPE_PEER2PEERPUSH \fP\fP
PEER2PEERPUSH\&. 
.TP
\fB\fIKINETIC_MESSAGE_TYPE_NOOP_RESPONSE \fP\fP
NOOP_RESPONSE\&. 
.TP
\fB\fIKINETIC_MESSAGE_TYPE_NOOP \fP\fP
NOOP\&. 
.TP
\fB\fIKINETIC_MESSAGE_TYPE_FLUSHALLDATA_RESPONSE \fP\fP
FLUSHALLDATA_RESPONSE\&. 
.TP
\fB\fIKINETIC_MESSAGE_TYPE_FLUSHALLDATA \fP\fP
FLUSHALLDATA\&. 
.TP
\fB\fIKINETIC_MESSAGE_TYPE_PINOP_RESPONSE \fP\fP
PINOP_RESPONSE\&. 
.TP
\fB\fIKINETIC_MESSAGE_TYPE_PINOP \fP\fP
PINOP\&. 
.TP
\fB\fIKINETIC_MESSAGE_TYPE_MEDIASCAN_RESPONSE \fP\fP
MEDIASCAN_RESPONSE\&. 
.TP
\fB\fIKINETIC_MESSAGE_TYPE_MEDIASCAN \fP\fP
MEDIASCAN\&. 
.TP
\fB\fIKINETIC_MESSAGE_TYPE_MEDIAOPTIMIZE_RESPONSE \fP\fP
MEDIAOPTIMIZE_RESPONSE\&. 
.TP
\fB\fIKINETIC_MESSAGE_TYPE_MEDIAOPTIMIZE \fP\fP
MEDIAOPTIMIZE\&. 
.PP
Definition at line 338 of file kinetic_types\&.h\&.
.SH "Function Documentation"
.PP 
.SS "const char* Kinetic_GetStatusDescription (\fBKineticStatus\fPstatus)"

.PP
Provides a string representation for a KineticStatus code\&. 
.PP
\fBParameters:\fP
.RS 4
\fIstatus\fP The status enumeration value\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Pointer to the appropriate string representation for the specified status\&. 
.RE
.PP

.PP
Definition at line 62 of file kinetic_types\&.c\&.
.PP
References KINETIC_STATUS_COUNT, KineticStatusDescriptor, and KineticStatusInvalid\&.
.SS "const char* KineticMessageType_GetName (\fBKineticMessageType\fPtype)"

.PP
Provides a string representation for a Kinetic message type\&. 
.PP
\fBParameters:\fP
.RS 4
\fItype\fP The message type value\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Pointer to the appropriate string representation for the specified type\&. 
.RE
.PP

.PP
Definition at line 107 of file kinetic_types\&.c\&.
.PP
References KINETIC_MESSAGE_TYPE_DELETE, KINETIC_MESSAGE_TYPE_DELETE_RESPONSE, KINETIC_MESSAGE_TYPE_FLUSHALLDATA, KINETIC_MESSAGE_TYPE_FLUSHALLDATA_RESPONSE, KINETIC_MESSAGE_TYPE_GET, KINETIC_MESSAGE_TYPE_GET_RESPONSE, KINETIC_MESSAGE_TYPE_GETKEYRANGE, KINETIC_MESSAGE_TYPE_GETKEYRANGE_RESPONSE, KINETIC_MESSAGE_TYPE_GETLOG, KINETIC_MESSAGE_TYPE_GETLOG_RESPONSE, KINETIC_MESSAGE_TYPE_GETNEXT, KINETIC_MESSAGE_TYPE_GETNEXT_RESPONSE, KINETIC_MESSAGE_TYPE_GETPREVIOUS, KINETIC_MESSAGE_TYPE_GETPREVIOUS_RESPONSE, KINETIC_MESSAGE_TYPE_GETVERSION, KINETIC_MESSAGE_TYPE_GETVERSION_RESPONSE, KINETIC_MESSAGE_TYPE_INVALID, KINETIC_MESSAGE_TYPE_MEDIAOPTIMIZE, KINETIC_MESSAGE_TYPE_MEDIAOPTIMIZE_RESPONSE, KINETIC_MESSAGE_TYPE_MEDIASCAN, KINETIC_MESSAGE_TYPE_MEDIASCAN_RESPONSE, KINETIC_MESSAGE_TYPE_NOOP, KINETIC_MESSAGE_TYPE_NOOP_RESPONSE, KINETIC_MESSAGE_TYPE_PEER2PEERPUSH, KINETIC_MESSAGE_TYPE_PEER2PEERPUSH_RESPONSE, KINETIC_MESSAGE_TYPE_PINOP, KINETIC_MESSAGE_TYPE_PINOP_RESPONSE, KINETIC_MESSAGE_TYPE_PUT, KINETIC_MESSAGE_TYPE_PUT_RESPONSE, KINETIC_MESSAGE_TYPE_SECURITY, KINETIC_MESSAGE_TYPE_SECURITY_RESPONSE, KINETIC_MESSAGE_TYPE_SETUP, and KINETIC_MESSAGE_TYPE_SETUP_RESPONSE\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for kinetic-c from the source code\&.
