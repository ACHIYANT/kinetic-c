.TH "kinetic_types.h" 3 "Wed Nov 5 2014" "Version v0.8.0" "kinetic-c" \" -*- nroff -*-
.ad l
.nh
.SH NAME
kinetic_types.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include <stdbool\&.h>\fP
.br
\fC#include <stdint\&.h>\fP
.br
\fC#include <inttypes\&.h>\fP
.br
\fC#include <stddef\&.h>\fP
.br
\fC#include <string\&.h>\fP
.br
\fC#include <stdio\&.h>\fP
.br
\fC#include <assert\&.h>\fP
.br
\fC#include <limits\&.h>\fP
.br
\fC#include <sys/time\&.h>\fP
.br
\fC#include 'byte_array\&.h'\fP
.br
\fC#include <unistd\&.h>\fP
.br
\fC#include <sys/types\&.h>\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBKineticSession\fP"
.br
.RI "\fIStructure used to specify the configuration of a session\&. \fP"
.ti -1c
.RI "struct \fBKineticCompletionData\fP"
.br
.ti -1c
.RI "struct \fBKineticCompletionClosure\fP"
.br
.ti -1c
.RI "struct \fBKineticEntry\fP"
.br
.ti -1c
.RI "struct \fBKineticKeyRange\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBKINETIC_HANDLE_INVALID\fP   (0)"
.br
.ti -1c
.RI "#define \fBKINETIC_PORT\fP   (8123)"
.br
.ti -1c
.RI "#define \fBKINETIC_TLS_PORT\fP   (8443)"
.br
.ti -1c
.RI "#define \fBKINETIC_HMAC_SHA1_LEN\fP   (SHA_DIGEST_LENGTH)"
.br
.ti -1c
.RI "#define \fBKINETIC_HMAC_MAX_LEN\fP   (\fBKINETIC_HMAC_SHA1_LEN\fP)"
.br
.ti -1c
.RI "#define \fBKINETIC_DEFAULT_KEY_LEN\fP   (1024)"
.br
.ti -1c
.RI "#define \fBKINETIC_MAX_KEY_LEN\fP   (4096)"
.br
.ti -1c
.RI "#define \fBKINETIC_MAX_VERSION_LEN\fP   (256)"
.br
.ti -1c
.RI "#define \fBKINETIC_OBJ_SIZE\fP   (1024 * 1024)"
.br
.ti -1c
.RI "#define \fB_BSD_SOURCE\fP"
.br
.ti -1c
.RI "#define \fBHOST_NAME_MAX\fP   256"
.br
.ti -1c
.RI "#define \fBLOG_FILE_NAME_MAX\fP   (\fBHOST_NAME_MAX\fP)"
.br
.ti -1c
.RI "#define \fBBOOL_TO_STRING\fP(_bool)   (_bool) ? 'true' : 'false'"
.br
.ti -1c
.RI "#define \fBKINETIC_SESSION_INIT\fP(_session, _host, _clusterVersion, _identity, _hmacKey)"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef int \fBKineticSessionHandle\fP"
.br
.RI "\fIHandle for a session instance\&. \fP"
.ti -1c
.RI "typedef void(* \fBKineticCompletionCallback\fP )(\fBKineticCompletionData\fP *kinetic_data, void *client_data)"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBKineticAlgorithm\fP "
.br
.RI "\fIEnumeration of encryption/checksum key algorithms\&. \fP"
.ti -1c
.RI "enum \fBKineticSynchronization\fP "
.br
.RI "\fIEnumeration of synchronization types for an operation\&. \fP"
.ti -1c
.RI "enum \fBKineticStatus\fP "
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "const char * \fBKinetic_GetStatusDescription\fP (\fBKineticStatus\fP status)"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define KINETIC_HANDLE_INVALID   (0)"

.PP
Definition at line 39 of file kinetic_types\&.h\&.
.SS "#define KINETIC_PORT   (8123)"

.PP
Definition at line 40 of file kinetic_types\&.h\&.
.SS "#define KINETIC_TLS_PORT   (8443)"

.PP
Definition at line 41 of file kinetic_types\&.h\&.
.SS "#define KINETIC_HMAC_SHA1_LEN   (SHA_DIGEST_LENGTH)"

.PP
Definition at line 42 of file kinetic_types\&.h\&.
.SS "#define KINETIC_HMAC_MAX_LEN   (\fBKINETIC_HMAC_SHA1_LEN\fP)"

.PP
Definition at line 43 of file kinetic_types\&.h\&.
.SS "#define KINETIC_DEFAULT_KEY_LEN   (1024)"

.PP
Definition at line 44 of file kinetic_types\&.h\&.
.SS "#define KINETIC_MAX_KEY_LEN   (4096)"

.PP
Definition at line 45 of file kinetic_types\&.h\&.
.SS "#define KINETIC_MAX_VERSION_LEN   (256)"

.PP
Definition at line 46 of file kinetic_types\&.h\&.
.SS "#define KINETIC_OBJ_SIZE   (1024 * 1024)"

.PP
Definition at line 47 of file kinetic_types\&.h\&.
.SS "#define _BSD_SOURCE"

.PP
Definition at line 52 of file kinetic_types\&.h\&.
.SS "#define HOST_NAME_MAX   256"

.PP
Definition at line 57 of file kinetic_types\&.h\&.
.SS "#define LOG_FILE_NAME_MAX   (\fBHOST_NAME_MAX\fP)"

.PP
Definition at line 61 of file kinetic_types\&.h\&.
.SS "#define BOOL_TO_STRING(_bool)   (_bool) ? 'true' : 'false'"

.PP
Definition at line 64 of file kinetic_types\&.h\&.
.SS "#define KINETIC_SESSION_INIT(_session, _host, _clusterVersion, _identity, _hmacKey)"
\fBValue:\fP
.PP
.nf
{ \
    *(_session) = (KineticSession) { \
        \&.port = KINETIC_PORT, \
        \&.clusterVersion = (_clusterVersion), \
        \&.identity = (_identity), \
        \&.hmacKey = {\&.data = (_session)->keyData, \&.len = (_hmacKey)\&.len}, \
    }; \
    strcpy((_session)->host, (_host)); \
    memcpy((_session)->hmacKey\&.data, (_hmacKey)\&.data, (_hmacKey)\&.len); \
}
.fi
.PP
Definition at line 125 of file kinetic_types\&.h\&.
.SH "Typedef Documentation"
.PP 
.SS "typedef int \fBKineticSessionHandle\fP"

.PP
Handle for a session instance\&. 
.PP
Definition at line 93 of file kinetic_types\&.h\&.
.SS "typedef void(* KineticCompletionCallback)(\fBKineticCompletionData\fP *kinetic_data, void *client_data)"

.PP
Definition at line 171 of file kinetic_types\&.h\&.
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBKineticAlgorithm\fP"

.PP
Enumeration of encryption/checksum key algorithms\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIKINETIC_ALGORITHM_INVALID \fP\fP
.TP
\fB\fIKINETIC_ALGORITHM_SHA1 \fP\fP
.TP
\fB\fIKINETIC_ALGORITHM_SHA2 \fP\fP
.TP
\fB\fIKINETIC_ALGORITHM_SHA3 \fP\fP
.TP
\fB\fIKINETIC_ALGORITHM_CRC32 \fP\fP
.TP
\fB\fIKINETIC_ALGORITHM_CRC64 \fP\fP
.PP
Definition at line 69 of file kinetic_types\&.h\&.
.SS "enum \fBKineticSynchronization\fP"

.PP
Enumeration of synchronization types for an operation\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIKINETIC_SYNCHRONIZATION_INVALID \fP\fP
.TP
\fB\fIKINETIC_SYNCHRONIZATION_WRITETHROUGH \fP\fP
.TP
\fB\fIKINETIC_SYNCHRONIZATION_WRITEBACK \fP\fP
.TP
\fB\fIKINETIC_SYNCHRONIZATION_FLUSH \fP\fP
.PP
Definition at line 82 of file kinetic_types\&.h\&.
.SS "enum \fBKineticStatus\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIKINETIC_STATUS_INVALID \fP\fP
.TP
\fB\fIKINETIC_STATUS_NOT_ATTEMPTED \fP\fP
.TP
\fB\fIKINETIC_STATUS_SUCCESS \fP\fP
.TP
\fB\fIKINETIC_STATUS_SESSION_EMPTY \fP\fP
.TP
\fB\fIKINETIC_STATUS_SESSION_INVALID \fP\fP
.TP
\fB\fIKINETIC_STATUS_HOST_EMPTY \fP\fP
.TP
\fB\fIKINETIC_STATUS_HMAC_EMPTY \fP\fP
.TP
\fB\fIKINETIC_STATUS_NO_PDUS_AVAVILABLE \fP\fP
.TP
\fB\fIKINETIC_STATUS_DEVICE_BUSY \fP\fP
.TP
\fB\fIKINETIC_STATUS_CONNECTION_ERROR \fP\fP
.TP
\fB\fIKINETIC_STATUS_INVALID_REQUEST \fP\fP
.TP
\fB\fIKINETIC_STATUS_OPERATION_INVALID \fP\fP
.TP
\fB\fIKINETIC_STATUS_OPERATION_FAILED \fP\fP
.TP
\fB\fIKINETIC_STATUS_CLUSTER_MISMATCH \fP\fP
.TP
\fB\fIKINETIC_STATUS_VERSION_MISMATCH \fP\fP
.TP
\fB\fIKINETIC_STATUS_DATA_ERROR \fP\fP
.TP
\fB\fIKINETIC_STATUS_NOT_FOUND \fP\fP
.TP
\fB\fIKINETIC_STATUS_BUFFER_OVERRUN \fP\fP
.TP
\fB\fIKINETIC_STATUS_MEMORY_ERROR \fP\fP
.TP
\fB\fIKINETIC_STATUS_SOCKET_TIMEOUT \fP\fP
.TP
\fB\fIKINETIC_STATUS_SOCKET_ERROR \fP\fP
.TP
\fB\fIKINETIC_STATUS_COUNT \fP\fP
.PP
Definition at line 137 of file kinetic_types\&.h\&.
.SH "Function Documentation"
.PP 
.SS "const char* Kinetic_GetStatusDescription (\fBKineticStatus\fPstatus)"

.PP
Definition at line 53 of file kinetic_types\&.c\&.
.PP
References KINETIC_STATUS_COUNT\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for kinetic-c from the source code\&.
