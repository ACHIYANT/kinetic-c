.TH "bus.h" 3 "Fri Mar 13 2015" "Version v0.12.0" "kinetic-c" \" -*- nroff -*-
.ad l
.nh
.SH NAME
bus.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'bus_types\&.h'\fP
.br
\fC#include 'bus_inward\&.h'\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "bool \fBBus_Init\fP (\fBbus_config\fP *config, struct \fBbus_result\fP *res)"
.br
.RI "\fIInitialize a bus, based on configuration in *config\&. \fP"
.ti -1c
.RI "bool \fBBus_SendRequest\fP (struct \fBbus\fP *b, \fBbus_user_msg\fP *msg)"
.br
.RI "\fISend a request\&. \fP"
.ti -1c
.RI "bool \fBBus_RegisterSocket\fP (struct \fBbus\fP *b, \fBbus_socket_t\fP type, int fd, void *socket_udata)"
.br
.RI "\fIRegister a socket connected to an endpoint, and data that will be passed to all interactions on that socket\&. \fP"
.ti -1c
.RI "bool \fBBus_ReleaseSocket\fP (struct \fBbus\fP *b, int fd, void **socket_udata_out)"
.br
.RI "\fIFree metadata about a socket that has been disconnected\&. \fP"
.ti -1c
.RI "bool \fBBus_Shutdown\fP (struct \fBbus\fP *b)"
.br
.RI "\fIBegin shutting the system down\&. \fP"
.ti -1c
.RI "void \fBBus_Free\fP (struct \fBbus\fP *b)"
.br
.RI "\fIFree internal data structures for the bus\&. \fP"
.in -1c
.SH "Function Documentation"
.PP 
.SS "bool Bus_Init (\fBbus_config\fP *config, struct \fBbus_result\fP *res)"

.PP
Initialize a bus, based on configuration in *config\&. Returns a bool indicating whether the construction succeeded, and the bus pointer and/or a status code indicating the cause of failure in *res\&. 
.PP
Definition at line 64 of file bus\&.c\&.
.PP
References attempt_to_increase_resource_limits(), bus_result::bus, BUS_INIT_ERROR_ALLOC_FAIL, BUS_INIT_ERROR_LISTENER_INIT_FAIL, BUS_INIT_ERROR_MISSING_SINK_CB, BUS_INIT_ERROR_MISSING_UNPACK_CB, BUS_INIT_ERROR_MUTEX_INIT_FAIL, BUS_INIT_ERROR_NULL, BUS_INIT_ERROR_PTHREAD_INIT_FAIL, BUS_INIT_ERROR_THREADPOOL_INIT_FAIL, BUS_LOG, BUS_LOG_SNPRINTF, bus_config::bus_udata, BusSSL_Init(), DEF_FD_SET_SIZE2, bus::error_cb, bus_config::error_cb, bus::fd_set, bus::fd_set_lock, bus::joined, bus::listener_count, bus_config::listener_count, Listener_Free(), Listener_Init(), bus::listeners, ListenerTask_MainLoop(), bus::log_cb, bus_config::log_cb, LOG_INITIALIZATION, bus::log_level, bus_config::log_level, noop_error_cb(), noop_log_cb(), set_defaults(), bus::sink_cb, bus_config::sink_cb, bus_result::status, bus::threadpool, bus_config::threadpool_cfg, Threadpool_Free(), Threadpool_Init(), threadpool::threads, bus::threads, bus::udata, bus::unexpected_msg_cb, bus_config::unexpected_msg_cb, bus::unpack_cb, bus_config::unpack_cb, Yacht_Free(), and Yacht_Init()\&.
.SS "bool Bus_SendRequest (struct \fBbus\fP *b, \fBbus_user_msg\fP *msg)"

.PP
Send a request\&. Blocks until the request has been transmitted\&.
.PP
Assumes the FD has been registered with Bus_register_socket; sending to an unregistered socket is an error\&.
.PP
Returns true if the request has been accepted and the bus will attempt to handle the request and response\&. They can still fail, but the error status will be passed to the result handler callback\&.
.PP
Returns false if the request has been rejected, due to a memory allocation error or invalid arguments\&. 
.PP
Definition at line 297 of file bus\&.c\&.
.PP
References box_msg(), BUS_LOG_SNPRINTF, bus_user_msg::fd, LOG_SENDING_REQUEST, Send_DoBlockingSend(), bus_user_msg::seq_id, and bus::udata\&.
.SS "bool Bus_RegisterSocket (struct \fBbus\fP *b, \fBbus_socket_t\fPtype, intfd, void *socket_udata)"

.PP
Register a socket connected to an endpoint, and data that will be passed to all interactions on that socket\&. The socket will have request -> response messages with timeouts, as well as unsolicited status messages\&.
.PP
If USES_SSL is true, then the function will block until the initial SSL/TLS connection handshake has completed\&. 
.PP
Definition at line 350 of file bus\&.c\&.
.PP
References BUS_LOG, BUS_LOG_SNPRINTF, BUS_NO_SEQ_ID, BUS_NO_SSL, BUS_SOCKET_SSL, BusPoll_OnCompletion(), BusSSL_Connect(), connection_info::fd, bus::fd_set, bus::fd_set_lock, connection_info::largest_wr_seq_id_seen, Listener_AddSocket(), listener_id_of_socket(), bus::listeners, LOG_SOCKET_REGISTERED, connection_info::ssl, connection_info::type, bus::udata, connection_info::udata, and Yacht_Set()\&.
.SS "bool Bus_ReleaseSocket (struct \fBbus\fP *b, intfd, void **socket_udata_out)"

.PP
Free metadata about a socket that has been disconnected\&. 
.PP
Definition at line 420 of file bus\&.c\&.
.PP
References BUS_LOG_SNPRINTF, BUS_NO_SSL, BusPoll_OnCompletion(), BusSSL_Disconnect(), bus::fd_set, bus::fd_set_lock, listener_id_of_socket(), Listener_RemoveSocket(), bus::listeners, LOG_SOCKET_REGISTERED, connection_info::ssl, bus::udata, connection_info::udata, and Yacht_Remove()\&.
.SS "bool Bus_Shutdown (struct \fBbus\fP *b)"

.PP
Begin shutting the system down\&. Returns true once everything pending has resolved\&. 
.PP
Definition at line 494 of file bus\&.c\&.
.PP
References ATOMIC_BOOL_COMPARE_AND_SWAP, BUS_LOG, BUS_LOG_SNPRINTF, BusPoll_OnCompletion(), bus::fd_set, free_connection_cb(), bus::joined, bus::listener_count, Listener_Shutdown(), bus::listeners, LOG_SHUTDOWN, bus::shutdown_state, SHUTDOWN_STATE_HALTED, SHUTDOWN_STATE_RUNNING, SHUTDOWN_STATE_SHUTTING_DOWN, syscall_pthread_join(), bus::threads, bus::udata, and Yacht_Free()\&.
.SS "void Bus_Free (struct \fBbus\fP *b)"

.PP
Free internal data structures for the bus\&. 
.PP
Definition at line 599 of file bus\&.c\&.
.PP
References BUS_LOG, BUS_LOG_SNPRINTF, Bus_Shutdown(), BusSSL_CtxFree(), bus::fd_set_lock, bus::joined, limit, bus::listener_count, Listener_Free(), bus::listeners, LOG_SHUTDOWN, bus::shutdown_state, SHUTDOWN_STATE_HALTED, syscall_poll(), THREAD_SHUTDOWN_SECONDS, bus::threadpool, Threadpool_Free(), Threadpool_Shutdown(), bus::threads, and bus::udata\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for kinetic-c from the source code\&.
