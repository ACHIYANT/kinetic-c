.TH "kinetic_client.h" 3 "Fri Mar 13 2015" "Version v0.12.0" "kinetic-c" \" -*- nroff -*-
.ad l
.nh
.SH NAME
kinetic_client.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'kinetic_types\&.h'\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "\fBKineticVersionInfo\fP \fBKineticClient_Version\fP (void)"
.br
.RI "\fIGets current version info of kinetic-c library\&. \fP"
.ti -1c
.RI "KineticClient * \fBKineticClient_Init\fP (\fBKineticClientConfig\fP *config)"
.br
.RI "\fIInitializes the Kinetic API and configures logging\&. \fP"
.ti -1c
.RI "void \fBKineticClient_Shutdown\fP (KineticClient *const client)"
.br
.RI "\fIPerforms shutdown/cleanup of the kinetic-c client library\&. \fP"
.ti -1c
.RI "\fBKineticStatus\fP \fBKineticClient_CreateSession\fP (\fBKineticSessionConfig\fP *const config, KineticClient *const client, KineticSession **session)"
.br
.RI "\fICreates a session with the Kinetic Device per specified configuration\&. \fP"
.ti -1c
.RI "\fBKineticStatus\fP \fBKineticClient_DestroySession\fP (KineticSession *const session)"
.br
.RI "\fICloses the connection to a host\&. \fP"
.ti -1c
.RI "\fBKineticStatus\fP \fBKineticClient_GetTerminationStatus\fP (KineticSession *const session)"
.br
.RI "\fIReturns the reason reported in the case of the Kinetic device terminating a session in the case of a catastrophic error occurring\&. \fP"
.ti -1c
.RI "\fBKineticStatus\fP \fBKineticClient_NoOp\fP (KineticSession *const session)"
.br
.RI "\fIExecutes a \fCNOOP\fP operation to test whether the Kinetic Device is operational\&. \fP"
.ti -1c
.RI "\fBKineticStatus\fP \fBKineticClient_Put\fP (KineticSession *const session, \fBKineticEntry\fP *const entry, \fBKineticCompletionClosure\fP *closure)"
.br
.RI "\fIExecutes a \fCPUT\fP operation to store/update an entry on the Kinetic Device\&. \fP"
.ti -1c
.RI "\fBKineticStatus\fP \fBKineticClient_Flush\fP (KineticSession *const session, \fBKineticCompletionClosure\fP *closure)"
.br
.RI "\fIExecutes a \fCFLUSHALLDATA\fP operation to flush pending PUTs or DELETEs\&. \fP"
.ti -1c
.RI "\fBKineticStatus\fP \fBKineticClient_Get\fP (KineticSession *const session, \fBKineticEntry\fP *const entry, \fBKineticCompletionClosure\fP *closure)"
.br
.RI "\fIExecutes a \fCGET\fP operation to retrieve an entry from the Kinetic Device\&. \fP"
.ti -1c
.RI "\fBKineticStatus\fP \fBKineticClient_GetPrevious\fP (KineticSession *const session, \fBKineticEntry\fP *const entry, \fBKineticCompletionClosure\fP *closure)"
.br
.RI "\fIExecutes a \fCGETPREVIOUS\fP operation to retrieve the next entry from the Kinetic Device\&. \fP"
.ti -1c
.RI "\fBKineticStatus\fP \fBKineticClient_GetNext\fP (KineticSession *const session, \fBKineticEntry\fP *const entry, \fBKineticCompletionClosure\fP *closure)"
.br
.RI "\fIExecutes a \fCGETNEXT\fP operation to retrieve the next entry from the Kinetic Device\&. \fP"
.ti -1c
.RI "\fBKineticStatus\fP \fBKineticClient_Delete\fP (KineticSession *const session, \fBKineticEntry\fP *const entry, \fBKineticCompletionClosure\fP *closure)"
.br
.RI "\fIExecutes a \fCDELETE\fP operation to delete an entry from the Kinetic Device\&. \fP"
.ti -1c
.RI "\fBKineticStatus\fP \fBKineticClient_GetKeyRange\fP (KineticSession *const session, \fBKineticKeyRange\fP *range, \fBByteBufferArray\fP *keys, \fBKineticCompletionClosure\fP *closure)"
.br
.RI "\fIExecutes a \fCGETKEYRANGE\fP operation to retrieve a set of keys in the range specified range from the Kinetic Device\&. \fP"
.ti -1c
.RI "\fBKineticStatus\fP \fBKineticClient_P2POperation\fP (KineticSession *const session, KineticP2P_Operation *const p2pOp, \fBKineticCompletionClosure\fP *closure)"
.br
.RI "\fIExecutes a \fCPEER2PEERPUSH\fP operation allows a client to instruct a Kinetic Device to copy a set of keys (and associated value and metadata) to another Kinetic Device\&. \fP"
.in -1c
.SH "Function Documentation"
.PP 
.SS "\fBKineticVersionInfo\fP KineticClient_Version (void)"

.PP
Gets current version info of kinetic-c library\&. 
.PP
\fBReturns:\fP
.RS 4
Returns a pointer to static version info 
.RE
.PP

.PP
Definition at line 42 of file kinetic_client\&.c\&.
.PP
References VersionInfo\&.
.SS "KineticClient* KineticClient_Init (\fBKineticClientConfig\fP *config)"

.PP
Initializes the Kinetic API and configures logging\&. 
.PP
\fBParameters:\fP
.RS 4
\fIconfig\fP A configuration struct\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Returns a pointer to a KineticClient\&. You need to pass this pointer to \fBKineticClient_CreateSession()\fP to create new connections\&. Once you are finished will the KineticClient, and there are no active connections\&. The pointer should be release with \fBKineticClient_Shutdown()\fP 
.RE
.PP

.PP
Definition at line 47 of file kinetic_client\&.c\&.
.PP
References KINETIC_CLIENT_DEFAULT_MAX_THREADPOOL_THREADS, KINETIC_CLIENT_DEFAULT_READER_THREADS, KineticBus_Init(), KineticCalloc(), KineticFree(), KineticLogger_Init(), KineticClientConfig::logFile, KineticClientConfig::logLevel, KineticClientConfig::maxThreadpoolThreads, and KineticClientConfig::readerThreads\&.
.SS "void KineticClient_Shutdown (KineticClient *constclient)"

.PP
Performs shutdown/cleanup of the kinetic-c client library\&. 
.PP
\fBParameters:\fP
.RS 4
\fIclient\fP The pointer returned from \fCKineticClient_Init\fP 
.RE
.PP

.PP
Definition at line 69 of file kinetic_client\&.c\&.
.PP
References KineticBus_Shutdown(), KineticFree(), and KineticLogger_Close()\&.
.SS "\fBKineticStatus\fP KineticClient_CreateSession (\fBKineticSessionConfig\fP *constconfig, KineticClient *constclient, KineticSession **session)"

.PP
Creates a session with the Kinetic Device per specified configuration\&. 
.PP
\fBParameters:\fP
.RS 4
\fIconfig\fP \fBKineticSessionConfig\fP structure which must be configured by the client prior to creating the device connection\&. \&.host Host name or IP address to connect to \&.port Port to establish socket connection on \&.clusterVersion Cluster version to use for the session \&.identity Identity to use for the session \&.hmacKey Key to use for HMAC calculations (NULL-terminated string) \&.pin PIN to use for PIN-based operations 
.br
\fIclient\fP The KineticClient pointer returned from \fBKineticClient_Init()\fP 
.br
\fIsession\fP Pointer to a KineticSession pointer that will be populated with the allocated/created session upon success\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Returns the resulting KineticStatus, and \fCsession\fP will be populated with a pointer to the session instance upon success\&. The client should call \fBKineticClient_DestroySession()\fP in order to shutdown a connection and cleanup resources when done using a KineticSession\&. 
.RE
.PP

.PP
Definition at line 76 of file kinetic_client\&.c\&.
.PP
References ByteArray::data, KineticSessionConfig::hmacKey, KineticSessionConfig::host, KINETIC_STATUS_HMAC_REQUIRED, KINETIC_STATUS_HOST_EMPTY, KINETIC_STATUS_MEMORY_ERROR, KINETIC_STATUS_SESSION_EMPTY, KINETIC_STATUS_SESSION_INVALID, KINETIC_STATUS_SUCCESS, KineticAllocator_FreeSession(), KineticAllocator_NewSession(), KineticSession_Connect(), KineticSession_Create(), ByteArray::len, LOG0, LOGF0, and KineticSessionConfig::port\&.
.SS "\fBKineticStatus\fP KineticClient_DestroySession (KineticSession *constsession)"

.PP
Closes the connection to a host\&. 
.PP
\fBParameters:\fP
.RS 4
\fIsession\fP The connected KineticSession to close\&. The session instance will be freed by this call after closing the connection, so the pointer should not longer be used\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Returns the resulting KineticStatus\&. 
.RE
.PP

.PP
Definition at line 126 of file kinetic_client\&.c\&.
.PP
References KINETIC_STATUS_SESSION_INVALID, KINETIC_STATUS_SUCCESS, KineticSession_Destroy(), KineticSession_Disconnect(), and LOG0\&.
.SS "\fBKineticStatus\fP KineticClient_GetTerminationStatus (KineticSession *constsession)"

.PP
Returns the reason reported in the case of the Kinetic device terminating a session in the case of a catastrophic error occurring\&. 
.PP
\fBParameters:\fP
.RS 4
\fIsession\fP The KineticSession to query\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Returns the status reported prior to termination or KINTEIC_STATUS_SUCCESS if not terminated\&. 
.RE
.PP

.PP
Definition at line 140 of file kinetic_client\&.c\&.
.PP
References KineticSession_GetTerminationStatus()\&.
.SS "\fBKineticStatus\fP KineticClient_NoOp (KineticSession *constsession)"

.PP
Executes a \fCNOOP\fP operation to test whether the Kinetic Device is operational\&. 
.PP
\fBParameters:\fP
.RS 4
\fIsession\fP The connected KineticSession to use for the operation\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Returns the resulting KineticStatus\&. 
.RE
.PP

.PP
Definition at line 145 of file kinetic_client\&.c\&.
.PP
References KINETIC_ASSERT, KINETIC_STATUS_MEMORY_ERROR, KineticAllocator_NewOperation(), KineticBuilder_BuildNoop(), and KineticController_ExecuteOperation()\&.
.SS "\fBKineticStatus\fP KineticClient_Put (KineticSession *constsession, \fBKineticEntry\fP *constentry, \fBKineticCompletionClosure\fP *closure)"

.PP
Executes a \fCPUT\fP operation to store/update an entry on the Kinetic Device\&. 
.PP
\fBParameters:\fP
.RS 4
\fIsession\fP The connected KineticSession to use for the operation\&. 
.br
\fIentry\fP Key/value entry for object to store\&. 'value' must specify the data to be stored\&. If a closure is provided this pointer must remain valid until the closure callback is called\&.
.br
\fIclosure\fP Optional closure\&. If specified, operation will be executed in asynchronous mode, and closure callback will be called upon completion in another thread\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Returns the resulting KineticStatus\&. 
.RE
.PP

.PP
Definition at line 156 of file kinetic_client\&.c\&.
.PP
References ByteBuffer::array, ByteArray::data, KINETIC_ASSERT, KINETIC_STATUS_MEMORY_ERROR, KINETIC_STATUS_SUCCESS, KineticAllocator_FreeOperation(), KineticAllocator_NewOperation(), KineticBuilder_BuildPut(), KineticController_ExecuteOperation(), ByteArray::len, and KineticEntry::value\&.
.SS "\fBKineticStatus\fP KineticClient_Flush (KineticSession *constsession, \fBKineticCompletionClosure\fP *closure)"

.PP
Executes a \fCFLUSHALLDATA\fP operation to flush pending PUTs or DELETEs\&. 
.PP
\fBParameters:\fP
.RS 4
\fIsession\fP The connected KineticSession to use for the operation\&. 
.br
\fIclosure\fP Optional closure\&. If specified, operation will be executed in asynchronous mode, and closure callback will be called upon completion in another thread\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Returns the resulting KineticStatus\&. 
.RE
.PP

.PP
Definition at line 184 of file kinetic_client\&.c\&.
.PP
References KINETIC_ASSERT, KINETIC_STATUS_MEMORY_ERROR, KineticAllocator_NewOperation(), KineticBuilder_BuildFlush(), and KineticController_ExecuteOperation()\&.
.SS "\fBKineticStatus\fP KineticClient_Get (KineticSession *constsession, \fBKineticEntry\fP *constentry, \fBKineticCompletionClosure\fP *closure)"

.PP
Executes a \fCGET\fP operation to retrieve an entry from the Kinetic Device\&. 
.PP
\fBParameters:\fP
.RS 4
\fIsession\fP The connected KineticSession to use for the operation\&. 
.br
\fIentry\fP Key/value entry for object to retrieve\&. 'value' will be populated unless 'metadataOnly' is set to 'true'\&. If a closure is provided this pointer must remain valid until the closure callback is called\&. 
.br
\fIclosure\fP Optional closure\&. If specified, operation will be executed in asynchronous mode, and closure callback will be called upon completion in another thread\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Returns the resulting KineticStatus\&. 
.RE
.PP

.PP
Definition at line 253 of file kinetic_client\&.c\&.
.PP
References CMD_GET, and handle_get_command()\&.
.SS "\fBKineticStatus\fP KineticClient_GetPrevious (KineticSession *constsession, \fBKineticEntry\fP *constentry, \fBKineticCompletionClosure\fP *closure)"

.PP
Executes a \fCGETPREVIOUS\fP operation to retrieve the next entry from the Kinetic Device\&. 
.PP
\fBParameters:\fP
.RS 4
\fIsession\fP The connected KineticSession to use for the operation\&. 
.br
\fIentry\fP Key/value entry for object to retrieve\&. 'value' will be populated unless 'metadataOnly' is set to 'true'\&. The key and value fields will be populated with the previous key and its corresponding value, according to lexicographical byte order\&. If a closure is provided this pointer must remain valid until the closure callback is called\&.
.br
\fIclosure\fP Optional closure\&. If specified, operation will be executed in asynchronous mode, and closure callback will be called upon completion in another thread\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Returns the resulting KineticStatus\&. 
.RE
.PP

.PP
Definition at line 260 of file kinetic_client\&.c\&.
.PP
References CMD_GET_PREVIOUS, and handle_get_command()\&.
.SS "\fBKineticStatus\fP KineticClient_GetNext (KineticSession *constsession, \fBKineticEntry\fP *constentry, \fBKineticCompletionClosure\fP *closure)"

.PP
Executes a \fCGETNEXT\fP operation to retrieve the next entry from the Kinetic Device\&. 
.PP
\fBParameters:\fP
.RS 4
\fIsession\fP The connected KineticSession to use for the operation\&. 
.br
\fIentry\fP Key/value entry for object to retrieve\&. 'value' will be populated unless 'metadataOnly' is set to 'true'\&. The key and value fields will be populated with the next key and its corresponding value, according to lexicographical byte order\&. If a closure is provided this pointer must remain valid until the closure callback is called\&.
.br
\fIclosure\fP Optional closure\&. If specified, operation will be executed in asynchronous mode, and closure callback will be called upon completion in another thread\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Returns the resulting KineticStatus\&. 
.RE
.PP

.PP
Definition at line 267 of file kinetic_client\&.c\&.
.PP
References CMD_GET_NEXT, and handle_get_command()\&.
.SS "\fBKineticStatus\fP KineticClient_Delete (KineticSession *constsession, \fBKineticEntry\fP *constentry, \fBKineticCompletionClosure\fP *closure)"

.PP
Executes a \fCDELETE\fP operation to delete an entry from the Kinetic Device\&. 
.PP
\fBParameters:\fP
.RS 4
\fIsession\fP The connected KineticSession to use for the operation\&. 
.br
\fIentry\fP Key/value entry for object to delete\&. 'value' is not used for this operation\&. 
.br
\fIclosure\fP Optional closure\&. If specified, operation will be executed in asynchronous mode, and closure callback will be called upon completion in another thread\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Returns the resulting KineticStatus\&. 
.RE
.PP

.PP
Definition at line 274 of file kinetic_client\&.c\&.
.PP
References KINETIC_ASSERT, KINETIC_STATUS_MEMORY_ERROR, KineticAllocator_NewOperation(), KineticBuilder_BuildDelete(), and KineticController_ExecuteOperation()\&.
.SS "\fBKineticStatus\fP KineticClient_GetKeyRange (KineticSession *constsession, \fBKineticKeyRange\fP *range, \fBByteBufferArray\fP *keys, \fBKineticCompletionClosure\fP *closure)"

.PP
Executes a \fCGETKEYRANGE\fP operation to retrieve a set of keys in the range specified range from the Kinetic Device\&. 
.PP
\fBParameters:\fP
.RS 4
\fIsession\fP The connected KineticSession to use for the operation 
.br
\fIrange\fP \fBKineticKeyRange\fP specifying keys to return 
.br
\fIkeys\fP \fBByteBufferArray\fP to store the retrieved keys\&. If a closure is provided, this must point to valid memory until the closure callback is called\&. 
.br
\fIclosure\fP Optional closure\&. If specified, operation will be executed in asynchronous mode, and closure callback will be called upon completion in another thread\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Returns 0 upon success, -1 or the Kinetic status code upon failure 
.RE
.PP

.PP
Definition at line 291 of file kinetic_client\&.c\&.
.PP
References ByteBufferArray::buffers, ByteBufferArray::count, KINETIC_ASSERT, KINETIC_STATUS_MEMORY_ERROR, KineticAllocator_NewOperation(), KineticBuilder_BuildGetKeyRange(), and KineticController_ExecuteOperation()\&.
.SS "\fBKineticStatus\fP KineticClient_P2POperation (KineticSession *constsession, KineticP2P_Operation *constp2pOp, \fBKineticCompletionClosure\fP *closure)"

.PP
Executes a \fCPEER2PEERPUSH\fP operation allows a client to instruct a Kinetic Device to copy a set of keys (and associated value and metadata) to another Kinetic Device\&. 
.PP
\fBParameters:\fP
.RS 4
\fIsession\fP The connected KineticSession to use for the operation 
.br
\fIp2pOp\fP KineticP2P_Operation pointer\&. This pointer needs to remain valid during the duration of the operation\&. The results of P2P operation(s) will be stored in the resultStatus field of this structure\&. 
.br
\fIclosure\fP Optional closure\&. If specified, operation will be executed in asynchronous mode, and closure callback will be called upon completion in another thread\&.
.RE
.PP
\fBReturns:\fP
.RS 4
Returns 0 upon success, -1 or the Kinetic status code upon failure\&. Note that P2P operations can be nested\&. This status code pertains to the initial top-level P2P operation\&. You'll need to check the resultStatus in the p2pOp structure to check the status of the individual P2P operations\&. 
.RE
.PP

.PP
Definition at line 312 of file kinetic_client\&.c\&.
.PP
References KINETIC_ASSERT, KINETIC_STATUS_MEMORY_ERROR, KINETIC_STATUS_SUCCESS, KineticAllocator_NewOperation(), KineticBuilder_BuildP2POperation(), and KineticController_ExecuteOperation()\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for kinetic-c from the source code\&.
